/** \file
 *  This C source file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44
 *
 *     -  From the grammar source file : gruntEval.g
 *     -                            On : 2009-03-20 09:47:20
 *     -           for the tree parser : gruntEvalTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

extern "C++"
{
#include "gruntRuntime.h"
#include "../z3D/Core/functor_inl.h"
#include "../z3D/Core/z_off_debug_new.h"
};

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "gruntEval.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pgruntEval_##scope##_SCOPE
#define SCOPE_STACK(scope)  pgruntEval_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pgruntEval_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   gruntEvalTokenNames[131+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "OP_UNARY_MINUS",
        (pANTLR3_UINT8) "OP_ASSIGN",
        (pANTLR3_UINT8) "OP_ADD_ASSIGN",
        (pANTLR3_UINT8) "OP_SUB_ASSIGN",
        (pANTLR3_UINT8) "OP_MUL_ASSIGN",
        (pANTLR3_UINT8) "OP_DIV_ASSIGN",
        (pANTLR3_UINT8) "OP_MOD_ASSIGN",
        (pANTLR3_UINT8) "OP_SHIFT_LEFT_ASSIGN",
        (pANTLR3_UINT8) "OP_SHIFT_RIGHT_ASSIGN",
        (pANTLR3_UINT8) "OP_AND_ASSIGN",
        (pANTLR3_UINT8) "OP_OR_ASSIGN",
        (pANTLR3_UINT8) "OP_XOR_ASSIGN",
        (pANTLR3_UINT8) "OP_CONDITIONAL",
        (pANTLR3_UINT8) "OP_LOGICAL_OR",
        (pANTLR3_UINT8) "OP_LOGICAL_AND",
        (pANTLR3_UINT8) "OP_BITWISE_OR",
        (pANTLR3_UINT8) "OP_BITWISE_XOR",
        (pANTLR3_UINT8) "OP_BITWISE_AND",
        (pANTLR3_UINT8) "OP_NOT_EQUAL",
        (pANTLR3_UINT8) "OP_EQUAL",
        (pANTLR3_UINT8) "OP_LESS",
        (pANTLR3_UINT8) "OP_LESS_EQUAL",
        (pANTLR3_UINT8) "OP_GREATER",
        (pANTLR3_UINT8) "OP_GREATER_EQUAL",
        (pANTLR3_UINT8) "OP_SHIFT_LEFT",
        (pANTLR3_UINT8) "OP_SHIFT_RIGHT",
        (pANTLR3_UINT8) "OP_ADD",
        (pANTLR3_UINT8) "OP_SUB",
        (pANTLR3_UINT8) "OP_MOD",
        (pANTLR3_UINT8) "OP_MUL",
        (pANTLR3_UINT8) "OP_DIV",
        (pANTLR3_UINT8) "OP_POST_INCR",
        (pANTLR3_UINT8) "OP_POST_DECR",
        (pANTLR3_UINT8) "OP_BITWISE_NOT",
        (pANTLR3_UINT8) "OP_LOGICAL_NOT",
        (pANTLR3_UINT8) "OP_NEGATE",
        (pANTLR3_UINT8) "OP_PRE_INCR",
        (pANTLR3_UINT8) "OP_PRE_DECR",
        (pANTLR3_UINT8) "OP_ELEMENT",
        (pANTLR3_UINT8) "OP_INDEX",
        (pANTLR3_UINT8) "OP_CALL_FUNC",
        (pANTLR3_UINT8) "COMMA_BLOCK",
        (pANTLR3_UINT8) "CP_BLOCK",
        (pANTLR3_UINT8) "ARGUMENT_LIST",
        (pANTLR3_UINT8) "PARAMETER_LIST",
        (pANTLR3_UINT8) "IF_STAT",
        (pANTLR3_UINT8) "SWITCH_STAT",
        (pANTLR3_UINT8) "SWITCH_CASE_LABEL",
        (pANTLR3_UINT8) "FOR_STAT",
        (pANTLR3_UINT8) "WHILE_STAT",
        (pANTLR3_UINT8) "DO_WHILE_STAT",
        (pANTLR3_UINT8) "LOCAL_DECLARATION_STAT",
        (pANTLR3_UINT8) "EMPTY_EXPR",
        (pANTLR3_UINT8) "BREAK_STAT",
        (pANTLR3_UINT8) "CONTINUE_STAT",
        (pANTLR3_UINT8) "FUNC_DEF",
        (pANTLR3_UINT8) "RETURN_STAT",
        (pANTLR3_UINT8) "THIS_FUNC",
        (pANTLR3_UINT8) "DICT_VALUE",
        (pANTLR3_UINT8) "DICT_ELEM_VALUE",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "STRING_BASIC_CHAR",
        (pANTLR3_UINT8) "STRING_ESC_SEQ",
        (pANTLR3_UINT8) "DECIMAL_INTEGER_LITERAL",
        (pANTLR3_UINT8) "HEXADECIMAL_INTEGER_LITERAL",
        (pANTLR3_UINT8) "FLOAT_LITERAL",
        (pANTLR3_UINT8) "FLOAT_EXPONENT",
        (pANTLR3_UINT8) "SL_COMMENT",
        (pANTLR3_UINT8) "ML_COMMENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "INCLUDE_FILENAME",
        (pANTLR3_UINT8) "LINE_COMMAND",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'continue'",
        (pANTLR3_UINT8) "'return'",
        (pANTLR3_UINT8) "'local'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'switch'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'case'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'default'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'+='",
        (pANTLR3_UINT8) "'-='",
        (pANTLR3_UINT8) "'*='",
        (pANTLR3_UINT8) "'/='",
        (pANTLR3_UINT8) "'%='",
        (pANTLR3_UINT8) "'<<='",
        (pANTLR3_UINT8) "'>>='",
        (pANTLR3_UINT8) "'&='",
        (pANTLR3_UINT8) "'|='",
        (pANTLR3_UINT8) "'^='",
        (pANTLR3_UINT8) "'?'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'|'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'<<'",
        (pANTLR3_UINT8) "'>>'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'~'",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'++'",
        (pANTLR3_UINT8) "'--'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'__this_func__'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	prog    (pgruntEval ctx);
static void	asnot    (pgruntEval ctx);
static gruntMemCell*	basic_stat    (pgruntEval ctx);
static gruntMemCell*	return_stat    (pgruntEval ctx);
static gruntMemCell*	stat    (pgruntEval ctx);
static gruntMemCell*	stat_no_scope    (pgruntEval ctx);
static gruntMemCell*	compound_stat_no_scope    (pgruntEval ctx);
static gruntMemCell*	compound_stat    (pgruntEval ctx);
static void	local_declaration_stat    (pgruntEval ctx);
static gruntMemCell*	function_definition    (pgruntEval ctx);
static gruntEval_get_func_def_return	get_func_def    (pgruntEval ctx);
static gruntEval_parameter_list_return	parameter_list    (pgruntEval ctx);
static gruntMemCell*	selection_stat    (pgruntEval ctx);
static gruntMemCell*	switch_stat    (pgruntEval ctx);
static gruntMemCell*	switch_default_exec    (pgruntEval ctx);
static gruntMemCell*	if_stat    (pgruntEval ctx);
static gruntMemCell*	iteration_stat    (pgruntEval ctx);
static gruntMemCell*	do_while_stat    (pgruntEval ctx);
static gruntMemCell*	while_stat    (pgruntEval ctx);
static gruntMemCell*	for_stat    (pgruntEval ctx);
static gruntMemCell*	expr    (pgruntEval ctx);
static gruntMemCell*	conditional_expr    (pgruntEval ctx);
static gruntMemCell*	call_func_expr    (pgruntEval ctx);
static gruntMemCell*	argument_list    (pgruntEval ctx);
static gruntMemCell*	dictionary_value    (pgruntEval ctx);
static ANTLR3_BOOLEAN	synpred1_gruntEval    (pgruntEval ctx);
static ANTLR3_BOOLEAN	synpred2_gruntEval    (pgruntEval ctx);
static ANTLR3_BOOLEAN	synpred3_gruntEval    (pgruntEval ctx);
static ANTLR3_BOOLEAN	synpred4_gruntEval    (pgruntEval ctx);
static void	gruntEvalFree(pgruntEval ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "gruntEval.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new gruntEval parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pgruntEval
gruntEvalNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return gruntEvalNewSSD(instream, NULL);
}

/** \brief Create a new gruntEval parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pgruntEval
gruntEvalNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pgruntEval ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pgruntEval) ANTLR3_CALLOC(1, sizeof(gruntEval));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in gruntEval.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our gruntEval interface
     */
    ctx->prog	= prog;
    ctx->asnot	= asnot;
    ctx->basic_stat	= basic_stat;
    ctx->return_stat	= return_stat;
    ctx->stat	= stat;
    ctx->stat_no_scope	= stat_no_scope;
    ctx->compound_stat_no_scope	= compound_stat_no_scope;
    ctx->compound_stat	= compound_stat;
    ctx->local_declaration_stat	= local_declaration_stat;
    ctx->function_definition	= function_definition;
    ctx->get_func_def	= get_func_def;
    ctx->parameter_list	= parameter_list;
    ctx->selection_stat	= selection_stat;
    ctx->switch_stat	= switch_stat;
    ctx->switch_default_exec	= switch_default_exec;
    ctx->if_stat	= if_stat;
    ctx->iteration_stat	= iteration_stat;
    ctx->do_while_stat	= do_while_stat;
    ctx->while_stat	= while_stat;
    ctx->for_stat	= for_stat;
    ctx->expr	= expr;
    ctx->conditional_expr	= conditional_expr;
    ctx->call_func_expr	= call_func_expr;
    ctx->argument_list	= argument_list;
    ctx->dictionary_value	= dictionary_value;
    ctx->synpred1_gruntEval	= synpred1_gruntEval;
    ctx->synpred2_gruntEval	= synpred2_gruntEval;
    ctx->synpred3_gruntEval	= synpred3_gruntEval;
    ctx->synpred4_gruntEval	= synpred4_gruntEval;
    ctx->free			= gruntEvalFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = gruntEvalTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 gruntEvalFree(pgruntEval ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return gruntEvalTokenNames; 
}


    	static ANTLR3_INT32		getCurNodeIndex(pgruntEval ctx)
    	{
    		ANTLR3_TREE_PARSER* parser = PARSER;
    		return parser->getTreeNodeStream(parser)->p;
    	}
    	template <class T>
    	T				exec_rule(pgruntEval ctx, ANTLR3_INT32 node_index, T (*rule) (pgruntEval))
    	{
    		ANTLR3_TREE_PARSER* parser = PARSER;
    		ANTLR3_COMMON_TREE_NODE_STREAM* tns = parser->getTreeNodeStream(parser);
    		tns->push(tns, node_index);
    		T ret = (*rule)(ctx);
    		tns->pop(tns);
    		return ret;
    	}
    	static void			exec_rule(pgruntEval ctx, ANTLR3_INT32 node_index, void (*rule) (pgruntEval))
    	{
    		ANTLR3_TREE_PARSER* parser = PARSER;
    		ANTLR3_COMMON_TREE_NODE_STREAM* tns = parser->getTreeNodeStream(parser);
    		tns->push(tns, node_index);
    		(*rule)(ctx);
    		tns->pop(tns);
    	}
    	static size_t			exec_in_switch_block(pgruntEval ctx, ANTLR3_INT32 node_index, gruntMemCell*& ret)
    	{
    		gruntMemCell* retval;
    		retval = exec_rule(ctx, node_index, &stat);
    		if(retval)
    		{
    			if(retval->getType() == gruntMemCell::TYPE_FLOWCTRL)
    			{
    				switch(retval->toFlowCtrl())
    				{
    				case gruntMemCell::FLOWCTRL_BREAK:
    					retval->getPool()->deleteCell(retval->getIndex());
    					return false;
    				case gruntMemCell::FLOWCTRL_CONTINUE:
    					ret = retval;
    					return false;
    				default:
    					Z_ASSERT( false );
    					break;
    				}
    			}
    			else if(retval->isReturnValue())
    			{
    				ret = retval;
    				return false;
    			}
    			else
    			{
    				Z_ASSERT( false );
    			}
    		}
    		return true;
    	}
    #define RUNTIME ((gruntRuntime*)PSRSTATE->userp)

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_stat_in_prog54  */
static	ANTLR3_BITWORD FOLLOW_stat_in_prog54_bits[]	= { ANTLR3_UINT64_LIT(0x7FF67FFFFFFFFFE2), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_stat_in_prog54	= { FOLLOW_stat_in_prog54_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_asnot69  */
static	ANTLR3_BITWORD FOLLOW_set_in_asnot69_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_asnot69	= { FOLLOW_set_in_asnot69_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_asnot79  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_asnot79_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_asnot79	= { FOLLOW_asnot_in_asnot79_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_basic_stat120  */
static	ANTLR3_BITWORD FOLLOW_expr_in_basic_stat120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_basic_stat120	= { FOLLOW_expr_in_basic_stat120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_BLOCK_in_basic_stat127  */
static	ANTLR3_BITWORD FOLLOW_COMMA_BLOCK_in_basic_stat127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_BLOCK_in_basic_stat127	= { FOLLOW_COMMA_BLOCK_in_basic_stat127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_basic_stat129  */
static	ANTLR3_BITWORD FOLLOW_expr_in_basic_stat129_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE8), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_basic_stat129	= { FOLLOW_expr_in_basic_stat129_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selection_stat_in_basic_stat137  */
static	ANTLR3_BITWORD FOLLOW_selection_stat_in_basic_stat137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selection_stat_in_basic_stat137	= { FOLLOW_selection_stat_in_basic_stat137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_iteration_stat_in_basic_stat147  */
static	ANTLR3_BITWORD FOLLOW_iteration_stat_in_basic_stat147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_iteration_stat_in_basic_stat147	= { FOLLOW_iteration_stat_in_basic_stat147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_local_declaration_stat_in_basic_stat157  */
static	ANTLR3_BITWORD FOLLOW_local_declaration_stat_in_basic_stat157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_local_declaration_stat_in_basic_stat157	= { FOLLOW_local_declaration_stat_in_basic_stat157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BREAK_STAT_in_basic_stat163  */
static	ANTLR3_BITWORD FOLLOW_BREAK_STAT_in_basic_stat163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BREAK_STAT_in_basic_stat163	= { FOLLOW_BREAK_STAT_in_basic_stat163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_STAT_in_basic_stat173  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_STAT_in_basic_stat173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_STAT_in_basic_stat173	= { FOLLOW_CONTINUE_STAT_in_basic_stat173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_return_stat_in_basic_stat183  */
static	ANTLR3_BITWORD FOLLOW_return_stat_in_basic_stat183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_return_stat_in_basic_stat183	= { FOLLOW_return_stat_in_basic_stat183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_STAT_in_return_stat217  */
static	ANTLR3_BITWORD FOLLOW_RETURN_STAT_in_return_stat217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_STAT_in_return_stat217	= { FOLLOW_RETURN_STAT_in_return_stat217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_return_stat222  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_return_stat222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_return_stat222	= { FOLLOW_asnot_in_return_stat222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basic_stat_in_stat245  */
static	ANTLR3_BITWORD FOLLOW_basic_stat_in_stat245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basic_stat_in_stat245	= { FOLLOW_basic_stat_in_stat245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_stat_in_stat254  */
static	ANTLR3_BITWORD FOLLOW_compound_stat_in_stat254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_stat_in_stat254	= { FOLLOW_compound_stat_in_stat254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basic_stat_in_stat_no_scope274  */
static	ANTLR3_BITWORD FOLLOW_basic_stat_in_stat_no_scope274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basic_stat_in_stat_no_scope274	= { FOLLOW_basic_stat_in_stat_no_scope274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_stat_no_scope_in_stat_no_scope283  */
static	ANTLR3_BITWORD FOLLOW_compound_stat_no_scope_in_stat_no_scope283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_stat_no_scope_in_stat_no_scope283	= { FOLLOW_compound_stat_no_scope_in_stat_no_scope283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CP_BLOCK_in_compound_stat_no_scope310  */
static	ANTLR3_BITWORD FOLLOW_CP_BLOCK_in_compound_stat_no_scope310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CP_BLOCK_in_compound_stat_no_scope310	= { FOLLOW_CP_BLOCK_in_compound_stat_no_scope310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_compound_stat_no_scope323  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_compound_stat_no_scope323_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_compound_stat_no_scope323	= { FOLLOW_asnot_in_compound_stat_no_scope323_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_stat_no_scope_in_compound_stat354  */
static	ANTLR3_BITWORD FOLLOW_compound_stat_no_scope_in_compound_stat354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_stat_no_scope_in_compound_stat354	= { FOLLOW_compound_stat_no_scope_in_compound_stat354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOCAL_DECLARATION_STAT_in_local_declaration_stat377  */
static	ANTLR3_BITWORD FOLLOW_LOCAL_DECLARATION_STAT_in_local_declaration_stat377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LOCAL_DECLARATION_STAT_in_local_declaration_stat377	= { FOLLOW_LOCAL_DECLARATION_STAT_in_local_declaration_stat377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_local_declaration_stat379  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_local_declaration_stat379_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_local_declaration_stat379	= { FOLLOW_IDENTIFIER_in_local_declaration_stat379_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_local_declaration_stat384  */
static	ANTLR3_BITWORD FOLLOW_expr_in_local_declaration_stat384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_local_declaration_stat384	= { FOLLOW_expr_in_local_declaration_stat384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNC_DEF_in_function_definition416  */
static	ANTLR3_BITWORD FOLLOW_FUNC_DEF_in_function_definition416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNC_DEF_in_function_definition416	= { FOLLOW_FUNC_DEF_in_function_definition416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_function_definition418  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_function_definition418_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_function_definition418	= { FOLLOW_asnot_in_function_definition418_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNC_DEF_in_get_func_def437  */
static	ANTLR3_BITWORD FOLLOW_FUNC_DEF_in_get_func_def437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNC_DEF_in_get_func_def437	= { FOLLOW_FUNC_DEF_in_get_func_def437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_list_in_get_func_def439  */
static	ANTLR3_BITWORD FOLLOW_parameter_list_in_get_func_def439_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_list_in_get_func_def439	= { FOLLOW_parameter_list_in_get_func_def439_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_get_func_def444  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_get_func_def444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_get_func_def444	= { FOLLOW_asnot_in_get_func_def444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETER_LIST_in_parameter_list474  */
static	ANTLR3_BITWORD FOLLOW_PARAMETER_LIST_in_parameter_list474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETER_LIST_in_parameter_list474	= { FOLLOW_PARAMETER_LIST_in_parameter_list474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parameter_list479  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parameter_list479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parameter_list479	= { FOLLOW_IDENTIFIER_in_parameter_list479_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_if_stat_in_selection_stat500  */
static	ANTLR3_BITWORD FOLLOW_if_stat_in_selection_stat500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_if_stat_in_selection_stat500	= { FOLLOW_if_stat_in_selection_stat500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_switch_stat_in_selection_stat508  */
static	ANTLR3_BITWORD FOLLOW_switch_stat_in_selection_stat508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_switch_stat_in_selection_stat508	= { FOLLOW_switch_stat_in_selection_stat508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_STAT_in_switch_stat534  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_STAT_in_switch_stat534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_STAT_in_switch_stat534	= { FOLLOW_SWITCH_STAT_in_switch_stat534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_switch_stat542  */
static	ANTLR3_BITWORD FOLLOW_expr_in_switch_stat542_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_switch_stat542	= { FOLLOW_expr_in_switch_stat542_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_switch_stat566  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_switch_stat566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_switch_stat566	= { FOLLOW_SWITCH_CASE_LABEL_in_switch_stat566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_switch_stat571  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_switch_stat571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_switch_stat571	= { FOLLOW_asnot_in_switch_stat571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_switch_stat586  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_switch_stat586_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_switch_stat586	= { FOLLOW_SWITCH_CASE_LABEL_in_switch_stat586_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_switch_stat608  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_switch_stat608_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_switch_stat608	= { FOLLOW_asnot_in_switch_stat608_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec668  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec668_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec668	= { FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_switch_default_exec670  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_switch_default_exec670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_switch_default_exec670	= { FOLLOW_asnot_in_switch_default_exec670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec683  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec683_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec683	= { FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec683_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_switch_default_exec700  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_switch_default_exec700_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_switch_default_exec700	= { FOLLOW_asnot_in_switch_default_exec700_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UP_in_switch_default_exec708  */
static	ANTLR3_BITWORD FOLLOW_UP_in_switch_default_exec708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UP_in_switch_default_exec708	= { FOLLOW_UP_in_switch_default_exec708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_STAT_in_if_stat732  */
static	ANTLR3_BITWORD FOLLOW_IF_STAT_in_if_stat732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_STAT_in_if_stat732	= { FOLLOW_IF_STAT_in_if_stat732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_if_stat737  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_if_stat737_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_if_stat737	= { FOLLOW_asnot_in_if_stat737_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_if_stat743  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_if_stat743_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_if_stat743	= { FOLLOW_asnot_in_if_stat743_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_if_stat749  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_if_stat749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_if_stat749	= { FOLLOW_asnot_in_if_stat749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_for_stat_in_iteration_stat772  */
static	ANTLR3_BITWORD FOLLOW_for_stat_in_iteration_stat772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_for_stat_in_iteration_stat772	= { FOLLOW_for_stat_in_iteration_stat772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_while_stat_in_iteration_stat779  */
static	ANTLR3_BITWORD FOLLOW_while_stat_in_iteration_stat779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_while_stat_in_iteration_stat779	= { FOLLOW_while_stat_in_iteration_stat779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_do_while_stat_in_iteration_stat786  */
static	ANTLR3_BITWORD FOLLOW_do_while_stat_in_iteration_stat786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_do_while_stat_in_iteration_stat786	= { FOLLOW_do_while_stat_in_iteration_stat786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DO_WHILE_STAT_in_do_while_stat812  */
static	ANTLR3_BITWORD FOLLOW_DO_WHILE_STAT_in_do_while_stat812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DO_WHILE_STAT_in_do_while_stat812	= { FOLLOW_DO_WHILE_STAT_in_do_while_stat812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_do_while_stat817  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_do_while_stat817_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_do_while_stat817	= { FOLLOW_asnot_in_do_while_stat817_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_do_while_stat823  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_do_while_stat823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_do_while_stat823	= { FOLLOW_asnot_in_do_while_stat823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_STAT_in_while_stat853  */
static	ANTLR3_BITWORD FOLLOW_WHILE_STAT_in_while_stat853_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_STAT_in_while_stat853	= { FOLLOW_WHILE_STAT_in_while_stat853_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_while_stat858  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_while_stat858_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_while_stat858	= { FOLLOW_asnot_in_while_stat858_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_while_stat864  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_while_stat864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_while_stat864	= { FOLLOW_asnot_in_while_stat864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_STAT_in_for_stat894  */
static	ANTLR3_BITWORD FOLLOW_FOR_STAT_in_for_stat894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_STAT_in_for_stat894	= { FOLLOW_FOR_STAT_in_for_stat894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_for_stat899  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_for_stat899_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_for_stat899	= { FOLLOW_asnot_in_for_stat899_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_for_stat905  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_for_stat905_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_for_stat905	= { FOLLOW_asnot_in_for_stat905_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_for_stat911  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_for_stat911_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_for_stat911	= { FOLLOW_asnot_in_for_stat911_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_for_stat917  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_for_stat917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_for_stat917	= { FOLLOW_asnot_in_for_stat917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EMPTY_EXPR_in_expr946  */
static	ANTLR3_BITWORD FOLLOW_EMPTY_EXPR_in_expr946_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EMPTY_EXPR_in_expr946	= { FOLLOW_EMPTY_EXPR_in_expr946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditional_expr_in_expr957  */
static	ANTLR3_BITWORD FOLLOW_conditional_expr_in_expr957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditional_expr_in_expr957	= { FOLLOW_conditional_expr_in_expr957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_ASSIGN_in_expr968  */
static	ANTLR3_BITWORD FOLLOW_OP_ASSIGN_in_expr968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_ASSIGN_in_expr968	= { FOLLOW_OP_ASSIGN_in_expr968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr972  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr972_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr972	= { FOLLOW_expr_in_expr972_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr976  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr976_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr976	= { FOLLOW_expr_in_expr976_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_ADD_ASSIGN_in_expr987  */
static	ANTLR3_BITWORD FOLLOW_OP_ADD_ASSIGN_in_expr987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_ADD_ASSIGN_in_expr987	= { FOLLOW_OP_ADD_ASSIGN_in_expr987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr991  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr991_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr991	= { FOLLOW_expr_in_expr991_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr995  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr995	= { FOLLOW_expr_in_expr995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SUB_ASSIGN_in_expr1005  */
static	ANTLR3_BITWORD FOLLOW_OP_SUB_ASSIGN_in_expr1005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SUB_ASSIGN_in_expr1005	= { FOLLOW_OP_SUB_ASSIGN_in_expr1005_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1009  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1009_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1009	= { FOLLOW_expr_in_expr1009_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1013  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1013	= { FOLLOW_expr_in_expr1013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_MUL_ASSIGN_in_expr1023  */
static	ANTLR3_BITWORD FOLLOW_OP_MUL_ASSIGN_in_expr1023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_MUL_ASSIGN_in_expr1023	= { FOLLOW_OP_MUL_ASSIGN_in_expr1023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1027  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1027_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1027	= { FOLLOW_expr_in_expr1027_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1031  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1031	= { FOLLOW_expr_in_expr1031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_DIV_ASSIGN_in_expr1041  */
static	ANTLR3_BITWORD FOLLOW_OP_DIV_ASSIGN_in_expr1041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_DIV_ASSIGN_in_expr1041	= { FOLLOW_OP_DIV_ASSIGN_in_expr1041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1045  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1045_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1045	= { FOLLOW_expr_in_expr1045_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1049  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1049	= { FOLLOW_expr_in_expr1049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_MOD_ASSIGN_in_expr1059  */
static	ANTLR3_BITWORD FOLLOW_OP_MOD_ASSIGN_in_expr1059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_MOD_ASSIGN_in_expr1059	= { FOLLOW_OP_MOD_ASSIGN_in_expr1059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1063  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1063_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1063	= { FOLLOW_expr_in_expr1063_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1067  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1067	= { FOLLOW_expr_in_expr1067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SHIFT_LEFT_ASSIGN_in_expr1077  */
static	ANTLR3_BITWORD FOLLOW_OP_SHIFT_LEFT_ASSIGN_in_expr1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SHIFT_LEFT_ASSIGN_in_expr1077	= { FOLLOW_OP_SHIFT_LEFT_ASSIGN_in_expr1077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1081  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1081_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1081	= { FOLLOW_expr_in_expr1081_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1085  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1085	= { FOLLOW_expr_in_expr1085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SHIFT_RIGHT_ASSIGN_in_expr1095  */
static	ANTLR3_BITWORD FOLLOW_OP_SHIFT_RIGHT_ASSIGN_in_expr1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SHIFT_RIGHT_ASSIGN_in_expr1095	= { FOLLOW_OP_SHIFT_RIGHT_ASSIGN_in_expr1095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1099  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1099_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1099	= { FOLLOW_expr_in_expr1099_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1103  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1103	= { FOLLOW_expr_in_expr1103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_AND_ASSIGN_in_expr1112  */
static	ANTLR3_BITWORD FOLLOW_OP_AND_ASSIGN_in_expr1112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_AND_ASSIGN_in_expr1112	= { FOLLOW_OP_AND_ASSIGN_in_expr1112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1116  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1116_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1116	= { FOLLOW_expr_in_expr1116_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1120  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1120	= { FOLLOW_expr_in_expr1120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_OR_ASSIGN_in_expr1130  */
static	ANTLR3_BITWORD FOLLOW_OP_OR_ASSIGN_in_expr1130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_OR_ASSIGN_in_expr1130	= { FOLLOW_OP_OR_ASSIGN_in_expr1130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1134  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1134_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1134	= { FOLLOW_expr_in_expr1134_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1138  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1138	= { FOLLOW_expr_in_expr1138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_XOR_ASSIGN_in_expr1149  */
static	ANTLR3_BITWORD FOLLOW_OP_XOR_ASSIGN_in_expr1149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_XOR_ASSIGN_in_expr1149	= { FOLLOW_OP_XOR_ASSIGN_in_expr1149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1153  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1153_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1153	= { FOLLOW_expr_in_expr1153_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1157  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1157	= { FOLLOW_expr_in_expr1157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_LOGICAL_OR_in_expr1167  */
static	ANTLR3_BITWORD FOLLOW_OP_LOGICAL_OR_in_expr1167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_LOGICAL_OR_in_expr1167	= { FOLLOW_OP_LOGICAL_OR_in_expr1167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1171  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1171_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1171	= { FOLLOW_expr_in_expr1171_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1175  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1175	= { FOLLOW_expr_in_expr1175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_LOGICAL_AND_in_expr1185  */
static	ANTLR3_BITWORD FOLLOW_OP_LOGICAL_AND_in_expr1185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_LOGICAL_AND_in_expr1185	= { FOLLOW_OP_LOGICAL_AND_in_expr1185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1189  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1189_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1189	= { FOLLOW_expr_in_expr1189_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1193  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1193	= { FOLLOW_expr_in_expr1193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_BITWISE_OR_in_expr1203  */
static	ANTLR3_BITWORD FOLLOW_OP_BITWISE_OR_in_expr1203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_BITWISE_OR_in_expr1203	= { FOLLOW_OP_BITWISE_OR_in_expr1203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1207  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1207_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1207	= { FOLLOW_expr_in_expr1207_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1211  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1211	= { FOLLOW_expr_in_expr1211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_BITWISE_XOR_in_expr1221  */
static	ANTLR3_BITWORD FOLLOW_OP_BITWISE_XOR_in_expr1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_BITWISE_XOR_in_expr1221	= { FOLLOW_OP_BITWISE_XOR_in_expr1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1225  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1225_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1225	= { FOLLOW_expr_in_expr1225_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1229  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1229	= { FOLLOW_expr_in_expr1229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_BITWISE_AND_in_expr1239  */
static	ANTLR3_BITWORD FOLLOW_OP_BITWISE_AND_in_expr1239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_BITWISE_AND_in_expr1239	= { FOLLOW_OP_BITWISE_AND_in_expr1239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1243  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1243_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1243	= { FOLLOW_expr_in_expr1243_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1247  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1247	= { FOLLOW_expr_in_expr1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_EQUAL_in_expr1257  */
static	ANTLR3_BITWORD FOLLOW_OP_EQUAL_in_expr1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_EQUAL_in_expr1257	= { FOLLOW_OP_EQUAL_in_expr1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1261  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1261_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1261	= { FOLLOW_expr_in_expr1261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1265  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1265	= { FOLLOW_expr_in_expr1265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_NOT_EQUAL_in_expr1276  */
static	ANTLR3_BITWORD FOLLOW_OP_NOT_EQUAL_in_expr1276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_NOT_EQUAL_in_expr1276	= { FOLLOW_OP_NOT_EQUAL_in_expr1276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1280  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1280_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1280	= { FOLLOW_expr_in_expr1280_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1284  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1284	= { FOLLOW_expr_in_expr1284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_LESS_in_expr1295  */
static	ANTLR3_BITWORD FOLLOW_OP_LESS_in_expr1295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_LESS_in_expr1295	= { FOLLOW_OP_LESS_in_expr1295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1299  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1299_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1299	= { FOLLOW_expr_in_expr1299_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1303  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1303	= { FOLLOW_expr_in_expr1303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_LESS_EQUAL_in_expr1314  */
static	ANTLR3_BITWORD FOLLOW_OP_LESS_EQUAL_in_expr1314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_LESS_EQUAL_in_expr1314	= { FOLLOW_OP_LESS_EQUAL_in_expr1314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1318  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1318_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1318	= { FOLLOW_expr_in_expr1318_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1322  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1322	= { FOLLOW_expr_in_expr1322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_GREATER_in_expr1332  */
static	ANTLR3_BITWORD FOLLOW_OP_GREATER_in_expr1332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_GREATER_in_expr1332	= { FOLLOW_OP_GREATER_in_expr1332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1336  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1336_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1336	= { FOLLOW_expr_in_expr1336_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1340  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1340	= { FOLLOW_expr_in_expr1340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_GREATER_EQUAL_in_expr1351  */
static	ANTLR3_BITWORD FOLLOW_OP_GREATER_EQUAL_in_expr1351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_GREATER_EQUAL_in_expr1351	= { FOLLOW_OP_GREATER_EQUAL_in_expr1351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1355  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1355_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1355	= { FOLLOW_expr_in_expr1355_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1359  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1359	= { FOLLOW_expr_in_expr1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SHIFT_LEFT_in_expr1369  */
static	ANTLR3_BITWORD FOLLOW_OP_SHIFT_LEFT_in_expr1369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SHIFT_LEFT_in_expr1369	= { FOLLOW_OP_SHIFT_LEFT_in_expr1369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1373  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1373_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1373	= { FOLLOW_expr_in_expr1373_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1377  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1377	= { FOLLOW_expr_in_expr1377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SHIFT_RIGHT_in_expr1387  */
static	ANTLR3_BITWORD FOLLOW_OP_SHIFT_RIGHT_in_expr1387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SHIFT_RIGHT_in_expr1387	= { FOLLOW_OP_SHIFT_RIGHT_in_expr1387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1391  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1391_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1391	= { FOLLOW_expr_in_expr1391_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1395  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1395	= { FOLLOW_expr_in_expr1395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_ADD_in_expr1405  */
static	ANTLR3_BITWORD FOLLOW_OP_ADD_in_expr1405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_ADD_in_expr1405	= { FOLLOW_OP_ADD_in_expr1405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1409  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1409_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1409	= { FOLLOW_expr_in_expr1409_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1413  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1413	= { FOLLOW_expr_in_expr1413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_SUB_in_expr1424  */
static	ANTLR3_BITWORD FOLLOW_OP_SUB_in_expr1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_SUB_in_expr1424	= { FOLLOW_OP_SUB_in_expr1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1428  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1428_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1428	= { FOLLOW_expr_in_expr1428_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1432  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1432	= { FOLLOW_expr_in_expr1432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_MOD_in_expr1443  */
static	ANTLR3_BITWORD FOLLOW_OP_MOD_in_expr1443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_MOD_in_expr1443	= { FOLLOW_OP_MOD_in_expr1443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1447  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1447_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1447	= { FOLLOW_expr_in_expr1447_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1451  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1451	= { FOLLOW_expr_in_expr1451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_MUL_in_expr1462  */
static	ANTLR3_BITWORD FOLLOW_OP_MUL_in_expr1462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_MUL_in_expr1462	= { FOLLOW_OP_MUL_in_expr1462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1466  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1466_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1466	= { FOLLOW_expr_in_expr1466_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1470  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1470	= { FOLLOW_expr_in_expr1470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_DIV_in_expr1481  */
static	ANTLR3_BITWORD FOLLOW_OP_DIV_in_expr1481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_DIV_in_expr1481	= { FOLLOW_OP_DIV_in_expr1481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1485  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1485_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1485	= { FOLLOW_expr_in_expr1485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1489  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1489	= { FOLLOW_expr_in_expr1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_BITWISE_NOT_in_expr1500  */
static	ANTLR3_BITWORD FOLLOW_OP_BITWISE_NOT_in_expr1500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_BITWISE_NOT_in_expr1500	= { FOLLOW_OP_BITWISE_NOT_in_expr1500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1504  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1504	= { FOLLOW_expr_in_expr1504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_LOGICAL_NOT_in_expr1515  */
static	ANTLR3_BITWORD FOLLOW_OP_LOGICAL_NOT_in_expr1515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_LOGICAL_NOT_in_expr1515	= { FOLLOW_OP_LOGICAL_NOT_in_expr1515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1519  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1519	= { FOLLOW_expr_in_expr1519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_NEGATE_in_expr1530  */
static	ANTLR3_BITWORD FOLLOW_OP_NEGATE_in_expr1530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_NEGATE_in_expr1530	= { FOLLOW_OP_NEGATE_in_expr1530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1534  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1534	= { FOLLOW_expr_in_expr1534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_PRE_INCR_in_expr1546  */
static	ANTLR3_BITWORD FOLLOW_OP_PRE_INCR_in_expr1546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_PRE_INCR_in_expr1546	= { FOLLOW_OP_PRE_INCR_in_expr1546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1550  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1550	= { FOLLOW_expr_in_expr1550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_PRE_DECR_in_expr1562  */
static	ANTLR3_BITWORD FOLLOW_OP_PRE_DECR_in_expr1562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_PRE_DECR_in_expr1562	= { FOLLOW_OP_PRE_DECR_in_expr1562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1566  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1566	= { FOLLOW_expr_in_expr1566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_POST_INCR_in_expr1578  */
static	ANTLR3_BITWORD FOLLOW_OP_POST_INCR_in_expr1578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_POST_INCR_in_expr1578	= { FOLLOW_OP_POST_INCR_in_expr1578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1582  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1582	= { FOLLOW_expr_in_expr1582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_POST_DECR_in_expr1594  */
static	ANTLR3_BITWORD FOLLOW_OP_POST_DECR_in_expr1594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_POST_DECR_in_expr1594	= { FOLLOW_OP_POST_DECR_in_expr1594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1598  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1598_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1598	= { FOLLOW_expr_in_expr1598_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_ELEMENT_in_expr1610  */
static	ANTLR3_BITWORD FOLLOW_OP_ELEMENT_in_expr1610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_ELEMENT_in_expr1610	= { FOLLOW_OP_ELEMENT_in_expr1610_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1614  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1614	= { FOLLOW_expr_in_expr1614_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expr1616  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expr1616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expr1616	= { FOLLOW_IDENTIFIER_in_expr1616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_INDEX_in_expr1626  */
static	ANTLR3_BITWORD FOLLOW_OP_INDEX_in_expr1626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_INDEX_in_expr1626	= { FOLLOW_OP_INDEX_in_expr1626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1630  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1630_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1630	= { FOLLOW_expr_in_expr1630_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr1634  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr1634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr1634	= { FOLLOW_expr_in_expr1634_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_func_expr_in_expr1644  */
static	ANTLR3_BITWORD FOLLOW_call_func_expr_in_expr1644_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_call_func_expr_in_expr1644	= { FOLLOW_call_func_expr_in_expr1644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_expr1655  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_expr1655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_expr1655	= { FOLLOW_STRING_LITERAL_in_expr1655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_INTEGER_LITERAL_in_expr1666  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_INTEGER_LITERAL_in_expr1666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_INTEGER_LITERAL_in_expr1666	= { FOLLOW_DECIMAL_INTEGER_LITERAL_in_expr1666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEXADECIMAL_INTEGER_LITERAL_in_expr1676  */
static	ANTLR3_BITWORD FOLLOW_HEXADECIMAL_INTEGER_LITERAL_in_expr1676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEXADECIMAL_INTEGER_LITERAL_in_expr1676	= { FOLLOW_HEXADECIMAL_INTEGER_LITERAL_in_expr1676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_LITERAL_in_expr1681  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_LITERAL_in_expr1681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_LITERAL_in_expr1681	= { FOLLOW_FLOAT_LITERAL_in_expr1681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expr1692  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expr1692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expr1692	= { FOLLOW_IDENTIFIER_in_expr1692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_definition_in_expr1703  */
static	ANTLR3_BITWORD FOLLOW_function_definition_in_expr1703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_definition_in_expr1703	= { FOLLOW_function_definition_in_expr1703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THIS_FUNC_in_expr1713  */
static	ANTLR3_BITWORD FOLLOW_THIS_FUNC_in_expr1713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THIS_FUNC_in_expr1713	= { FOLLOW_THIS_FUNC_in_expr1713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dictionary_value_in_expr1724  */
static	ANTLR3_BITWORD FOLLOW_dictionary_value_in_expr1724_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dictionary_value_in_expr1724	= { FOLLOW_dictionary_value_in_expr1724_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_CONDITIONAL_in_conditional_expr1753  */
static	ANTLR3_BITWORD FOLLOW_OP_CONDITIONAL_in_conditional_expr1753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_CONDITIONAL_in_conditional_expr1753	= { FOLLOW_OP_CONDITIONAL_in_conditional_expr1753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_conditional_expr1757  */
static	ANTLR3_BITWORD FOLLOW_expr_in_conditional_expr1757_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_conditional_expr1757	= { FOLLOW_expr_in_conditional_expr1757_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_conditional_expr1762  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_conditional_expr1762_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_conditional_expr1762	= { FOLLOW_asnot_in_conditional_expr1762_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_conditional_expr1768  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_conditional_expr1768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_conditional_expr1768	= { FOLLOW_asnot_in_conditional_expr1768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OP_CALL_FUNC_in_call_func_expr1798  */
static	ANTLR3_BITWORD FOLLOW_OP_CALL_FUNC_in_call_func_expr1798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OP_CALL_FUNC_in_call_func_expr1798	= { FOLLOW_OP_CALL_FUNC_in_call_func_expr1798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_call_func_expr1802  */
static	ANTLR3_BITWORD FOLLOW_expr_in_call_func_expr1802_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF8), ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR3_UINT64_LIT(0x000000000000007F) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_call_func_expr1802	= { FOLLOW_expr_in_call_func_expr1802_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_call_func_expr1807  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_call_func_expr1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_call_func_expr1807	= { FOLLOW_asnot_in_call_func_expr1807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARGUMENT_LIST_in_argument_list1837  */
static	ANTLR3_BITWORD FOLLOW_ARGUMENT_LIST_in_argument_list1837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ARGUMENT_LIST_in_argument_list1837	= { FOLLOW_ARGUMENT_LIST_in_argument_list1837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_argument_list1840  */
static	ANTLR3_BITWORD FOLLOW_expr_in_argument_list1840_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE8), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_argument_list1840	= { FOLLOW_expr_in_argument_list1840_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DICT_VALUE_in_dictionary_value1869  */
static	ANTLR3_BITWORD FOLLOW_DICT_VALUE_in_dictionary_value1869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DICT_VALUE_in_dictionary_value1869	= { FOLLOW_DICT_VALUE_in_dictionary_value1869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DICT_ELEM_VALUE_in_dictionary_value1881  */
static	ANTLR3_BITWORD FOLLOW_DICT_ELEM_VALUE_in_dictionary_value1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DICT_ELEM_VALUE_in_dictionary_value1881	= { FOLLOW_DICT_ELEM_VALUE_in_dictionary_value1881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_dictionary_value1888  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_dictionary_value1888_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_dictionary_value1888	= { FOLLOW_IDENTIFIER_in_dictionary_value1888_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_dictionary_value1896  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_dictionary_value1896_bits[]	= { ANTLR3_UINT64_LIT(0x69001FFFFFFFFFE0), ANTLR3_UINT64_LIT(0x0000000000000073) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_dictionary_value1896	= { FOLLOW_STRING_LITERAL_in_dictionary_value1896_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_dictionary_value1899  */
static	ANTLR3_BITWORD FOLLOW_expr_in_dictionary_value1899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_dictionary_value1899	= { FOLLOW_expr_in_dictionary_value1899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_synpred1_gruntEval557  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_synpred1_gruntEval557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_synpred1_gruntEval557	= { FOLLOW_SWITCH_CASE_LABEL_in_synpred1_gruntEval557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_synpred1_gruntEval559  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_synpred1_gruntEval559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_synpred1_gruntEval559	= { FOLLOW_asnot_in_synpred1_gruntEval559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_synpred2_gruntEval581  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_synpred2_gruntEval581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_synpred2_gruntEval581	= { FOLLOW_SWITCH_CASE_LABEL_in_synpred2_gruntEval581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_synpred3_gruntEval659  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_synpred3_gruntEval659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_synpred3_gruntEval659	= { FOLLOW_SWITCH_CASE_LABEL_in_synpred3_gruntEval659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_asnot_in_synpred3_gruntEval661  */
static	ANTLR3_BITWORD FOLLOW_asnot_in_synpred3_gruntEval661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_asnot_in_synpred3_gruntEval661	= { FOLLOW_asnot_in_synpred3_gruntEval661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_CASE_LABEL_in_synpred4_gruntEval678  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_CASE_LABEL_in_synpred4_gruntEval678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_CASE_LABEL_in_synpred4_gruntEval678	= { FOLLOW_SWITCH_CASE_LABEL_in_synpred4_gruntEval678_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    85:1: asnot : ( ^( (~ ( UP | DOWN ) ) ( asnot )* ) | . );
 */
static const ANTLR3_INT32 dfa3_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_min[7] =
    {
	4, 2, 3, -1, 2, -1, -1
    };
static const ANTLR3_INT32 dfa3_max[7] =
    {
	134, 134, 134, -1, 134, -1, -1
    };
static const ANTLR3_INT32 dfa3_accept[7] =
    {
	-1, -1, -1, 2, -1, 1, 1
    };
static const ANTLR3_INT32 dfa3_special[7] =
    {	
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa3_T_empty	    NULL

static const ANTLR3_INT32 dfa3_T0[] =
    {
	5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa3_T1[] =
    {
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa3_T2[] =
    {
	5, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa3_T3[] =
    {
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa3_transitions[] =
{
    dfa3_T3, dfa3_T1, dfa3_T0, dfa3_T_empty, dfa3_T2, dfa3_T_empty, dfa3_T_empty	
};


/* Declare tracking structure for Cyclic DFA 3
 */
static
ANTLR3_CYCLIC_DFA cdfa3
    =	{
	    3,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"85:1: asnot : ( ^( (~ ( UP | DOWN ) ) ( asnot )* ) | . );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa3_eot,	    /* EOT table			    */
	    dfa3_eof,	    /* EOF table			    */
	    dfa3_min,	    /* Minimum tokens for each state    */
	    dfa3_max,	    /* Maximum tokens for each state    */
	    dfa3_accept,	/* Accept table			    */
	    dfa3_special,	/* Special transition states	    */
	    dfa3_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 3
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start prog
 * gruntEval.g:80:1: prog : ( stat )* ;
 */
static void
prog(pgruntEval ctx)
{   
    /* Initialize rule variables
     */


    {
        // gruntEval.g:81:2: ( ( stat )* )
        // gruntEval.g:81:4: ( stat )*
        {

            // gruntEval.g:81:4: ( stat )*

            for (;;)
            {
                int alt1=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA1_0 = LA(1);
                    if ( (((LA1_0 >= OP_ASSIGN) && (LA1_0 <= CP_BLOCK)) || ((LA1_0 >= IF_STAT) && (LA1_0 <= SWITCH_STAT)) || ((LA1_0 >= FOR_STAT) && (LA1_0 <= DICT_VALUE)) || ((LA1_0 >= IDENTIFIER) && (LA1_0 <= STRING_LITERAL)) || ((LA1_0 >= DECIMAL_INTEGER_LITERAL) && (LA1_0 <= FLOAT_LITERAL))) ) 
                    {
                        alt1=1;
                    }

                }
                switch (alt1) 
                {
            	case 1:
            	    // gruntEval.g:81:4: stat
            	    {
            	        FOLLOWPUSH(FOLLOW_stat_in_prog54);
            	        stat(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end prog */

/** 
 * $ANTLR start asnot
 * gruntEval.g:85:1: asnot : ( ^( (~ ( UP | DOWN ) ) ( asnot )* ) | . );
 */
static void
asnot(pgruntEval ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  gruntEval.g:86:2: ( ^( (~ ( UP | DOWN ) ) ( asnot )* ) | . )
            
            ANTLR3_UINT32 alt3;

            alt3=2;

            alt3 = cdfa3.predict(ctx, RECOGNIZER, ISTREAM, &cdfa3);
            if  (HASEXCEPTION())
            {
                goto ruleasnotEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt3) 
            {
        	case 1:
        	    // gruntEval.g:86:4: ^( (~ ( UP | DOWN ) ) ( asnot )* )
        	    {
        	        // gruntEval.g:86:6: (~ ( UP | DOWN ) )
        	        // gruntEval.g:86:7: ~ ( UP | DOWN )
        	        {
        	            if ( ((LA(1) >= OP_UNARY_MINUS) && (LA(1) <= 134)) )
        	            {
        	                CONSUME();
        	                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_asnot69);    goto ruleasnotEx;
        	            }


        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleasnotEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // gruntEval.g:86:21: ( asnot )*

        	            for (;;)
        	            {
        	                int alt2=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA2_0 = LA(1);
        	                    if ( (((LA2_0 >= OP_UNARY_MINUS) && (LA2_0 <= 134))) ) 
        	                    {
        	                        alt2=1;
        	                    }

        	                }
        	                switch (alt2) 
        	                {
        	            	case 1:
        	            	    // gruntEval.g:86:21: asnot
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_asnot_in_asnot79);
        	            	        asnot(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleasnotEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop2;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop2: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleasnotEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:87:4: .
        	    {
        	        MATCHANYT(); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleasnotEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleasnotEx; /* Prevent compiler warnings */
    ruleasnotEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end asnot */

/** 
 * $ANTLR start basic_stat
 * gruntEval.g:91:1: basic_stat returns [gruntMemCell* value = 0] : (e= expr | ^( COMMA_BLOCK ( expr )+ ) | selection_stat | iteration_stat | local_declaration_stat | BREAK_STAT | CONTINUE_STAT | return_stat ) ;
 */
static gruntMemCell*
basic_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e gruntMemCell*

    gruntMemCell* selection_stat1;
    #undef	RETURN_TYPE_selection_stat1
    #define	RETURN_TYPE_selection_stat1 gruntMemCell*

    gruntMemCell* iteration_stat2;
    #undef	RETURN_TYPE_iteration_stat2
    #define	RETURN_TYPE_iteration_stat2 gruntMemCell*

    gruntMemCell* return_stat3;
    #undef	RETURN_TYPE_return_stat3
    #define	RETURN_TYPE_return_stat3 gruntMemCell*

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    	
    e = NULL;
    selection_stat1 = NULL;
    iteration_stat2 = NULL;
    return_stat3 = NULL;

    {
        // gruntEval.g:97:2: ( (e= expr | ^( COMMA_BLOCK ( expr )+ ) | selection_stat | iteration_stat | local_declaration_stat | BREAK_STAT | CONTINUE_STAT | return_stat ) )
        // gruntEval.g:97:4: (e= expr | ^( COMMA_BLOCK ( expr )+ ) | selection_stat | iteration_stat | local_declaration_stat | BREAK_STAT | CONTINUE_STAT | return_stat )
        {

            // gruntEval.g:97:4: (e= expr | ^( COMMA_BLOCK ( expr )+ ) | selection_stat | iteration_stat | local_declaration_stat | BREAK_STAT | CONTINUE_STAT | return_stat )
            {
                int alt5=8;
                switch ( LA(1) ) 
                {
                case OP_ASSIGN:
                case OP_ADD_ASSIGN:
                case OP_SUB_ASSIGN:
                case OP_MUL_ASSIGN:
                case OP_DIV_ASSIGN:
                case OP_MOD_ASSIGN:
                case OP_SHIFT_LEFT_ASSIGN:
                case OP_SHIFT_RIGHT_ASSIGN:
                case OP_AND_ASSIGN:
                case OP_OR_ASSIGN:
                case OP_XOR_ASSIGN:
                case OP_CONDITIONAL:
                case OP_LOGICAL_OR:
                case OP_LOGICAL_AND:
                case OP_BITWISE_OR:
                case OP_BITWISE_XOR:
                case OP_BITWISE_AND:
                case OP_NOT_EQUAL:
                case OP_EQUAL:
                case OP_LESS:
                case OP_LESS_EQUAL:
                case OP_GREATER:
                case OP_GREATER_EQUAL:
                case OP_SHIFT_LEFT:
                case OP_SHIFT_RIGHT:
                case OP_ADD:
                case OP_SUB:
                case OP_MOD:
                case OP_MUL:
                case OP_DIV:
                case OP_POST_INCR:
                case OP_POST_DECR:
                case OP_BITWISE_NOT:
                case OP_LOGICAL_NOT:
                case OP_NEGATE:
                case OP_PRE_INCR:
                case OP_PRE_DECR:
                case OP_ELEMENT:
                case OP_INDEX:
                case OP_CALL_FUNC:
                case EMPTY_EXPR:
                case FUNC_DEF:
                case THIS_FUNC:
                case DICT_VALUE:
                case IDENTIFIER:
                case STRING_LITERAL:
                case DECIMAL_INTEGER_LITERAL:
                case HEXADECIMAL_INTEGER_LITERAL:
                case FLOAT_LITERAL:
                	{
                		alt5=1;
                	}
                    break;
                case COMMA_BLOCK:
                	{
                		alt5=2;
                	}
                    break;
                case IF_STAT:
                case SWITCH_STAT:
                	{
                		alt5=3;
                	}
                    break;
                case FOR_STAT:
                case WHILE_STAT:
                case DO_WHILE_STAT:
                	{
                		alt5=4;
                	}
                    break;
                case LOCAL_DECLARATION_STAT:
                	{
                		alt5=5;
                	}
                    break;
                case BREAK_STAT:
                	{
                		alt5=6;
                	}
                    break;
                case CONTINUE_STAT:
                	{
                		alt5=7;
                	}
                    break;
                case RETURN_STAT:
                	{
                		alt5=8;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE; 
                        return value;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 5;
                    EXCEPTION->state        = 0;


                    goto rulebasic_statEx;
                }

                switch (alt5) 
                {
            	case 1:
            	    // gruntEval.g:98:4: e= expr
            	    {
            	        FOLLOWPUSH(FOLLOW_expr_in_basic_stat120);
            	        e=expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 2:
            	    // gruntEval.g:99:5: ^( COMMA_BLOCK ( expr )+ )
            	    {
            	         MATCHT(COMMA_BLOCK, &FOLLOW_COMMA_BLOCK_in_basic_stat127); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        // gruntEval.g:99:19: ( expr )+
            	        {
            	            int cnt4=0;

            	            for (;;)
            	            {
            	                int alt4=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA4_0 = LA(1);
            	        	    if ( (((LA4_0 >= OP_ASSIGN) && (LA4_0 <= OP_CALL_FUNC)) || LA4_0 == EMPTY_EXPR || LA4_0 == FUNC_DEF || ((LA4_0 >= THIS_FUNC) && (LA4_0 <= DICT_VALUE)) || ((LA4_0 >= IDENTIFIER) && (LA4_0 <= STRING_LITERAL)) || ((LA4_0 >= DECIMAL_INTEGER_LITERAL) && (LA4_0 <= FLOAT_LITERAL))) ) 
            	        	    {
            	        	        alt4=1;
            	        	    }

            	        	}
            	        	switch (alt4) 
            	        	{
            	        	    case 1:
            	        	        // gruntEval.g:99:19: expr
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_expr_in_basic_stat129);
            	        	            expr(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulebasic_statEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return value;
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt4 >= 1 )
            	        		{
            	        		    goto loop4;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE; 
            	        		    return value;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulebasic_statEx;
            	        	}
            	        	cnt4++;
            	            }
            	            loop4: ;	/* Jump to here if this rule does not match */
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 3:
            	    // gruntEval.g:100:5: selection_stat
            	    {
            	        FOLLOWPUSH(FOLLOW_selection_stat_in_basic_stat137);
            	        selection_stat1=selection_stat(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= selection_stat1;
            	        }

            	    }
            	    break;
            	case 4:
            	    // gruntEval.g:101:5: iteration_stat
            	    {
            	        FOLLOWPUSH(FOLLOW_iteration_stat_in_basic_stat147);
            	        iteration_stat2=iteration_stat(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= iteration_stat2;
            	        }

            	    }
            	    break;
            	case 5:
            	    // gruntEval.g:102:5: local_declaration_stat
            	    {
            	        FOLLOWPUSH(FOLLOW_local_declaration_stat_in_basic_stat157);
            	        local_declaration_stat(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 6:
            	    // gruntEval.g:103:5: BREAK_STAT
            	    {
            	         MATCHT(BREAK_STAT, &FOLLOW_BREAK_STAT_in_basic_stat163); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            if(runtime.canBreak()) {value= runtime.addCell(L""); value->asFlowCtrl() = gruntMemCell::FLOWCTRL_BREAK;} else printf("can't break\n");
            	        }

            	    }
            	    break;
            	case 7:
            	    // gruntEval.g:104:5: CONTINUE_STAT
            	    {
            	         MATCHT(CONTINUE_STAT, &FOLLOW_CONTINUE_STAT_in_basic_stat173); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            if(runtime.canContinue()) {value= runtime.addCell(L""); value->asFlowCtrl() = gruntMemCell::FLOWCTRL_CONTINUE;} else printf("can't continue\n");
            	        }

            	    }
            	    break;
            	case 8:
            	    // gruntEval.g:105:5: return_stat
            	    {
            	        FOLLOWPUSH(FOLLOW_return_stat_in_basic_stat183);
            	        return_stat3=return_stat(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasic_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= return_stat3;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                runtime.clearTemp();
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebasic_statEx; /* Prevent compiler warnings */
    rulebasic_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end basic_stat */

/** 
 * $ANTLR start return_stat
 * gruntEval.g:109:1: return_stat returns [gruntMemCell* value = 0] : ^( RETURN_STAT ( asnot )? ) ;
 */
static gruntMemCell*
return_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		ANTLR3_INT32 e_index = -1;
    		gruntRuntime& runtime = *RUNTIME;
    	
    {
        // gruntEval.g:116:2: ( ^( RETURN_STAT ( asnot )? ) )
        // gruntEval.g:116:4: ^( RETURN_STAT ( asnot )? )
        {
             MATCHT(RETURN_STAT, &FOLLOW_RETURN_STAT_in_return_stat217); 
            if  (HASEXCEPTION())
            {
                goto rulereturn_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulereturn_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

                // gruntEval.g:116:18: ( asnot )?
                {
                    int alt6=2;
                    {
                        int LA6_0 = LA(1);
                        if ( (((LA6_0 >= OP_UNARY_MINUS) && (LA6_0 <= 134))) ) 
                        {
                            alt6=1;
                        }
                    }
                    switch (alt6) 
                    {
                	case 1:
                	    // gruntEval.g:116:19: asnot
                	    {
                	        if ( BACKTRACKING==0 ) 
                	        {
                	            e_index = getCurNodeIndex(ctx);
                	        }
                	        FOLLOWPUSH(FOLLOW_asnot_in_return_stat222);
                	        asnot(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulereturn_statEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulereturn_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }
            }
            if ( BACKTRACKING==0 ) 
            {

                			if(runtime.canReturn())
                			{
                				if(e_index != -1)
                				{
                					gruntMemCell* ret = exec_rule(ctx, e_index, &expr);
                					value= runtime.addCell(L"");
                					runtime.op_assign(value, ret);
                				}
                				else
                					value= runtime.addCell(L"");
                				value->flagAsReturnValue(true);
                			}
                			else
                			{
                				printf("can't return\n");
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereturn_statEx; /* Prevent compiler warnings */
    rulereturn_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end return_stat */

/** 
 * $ANTLR start stat
 * gruntEval.g:137:1: stat returns [gruntMemCell* value = 0] : ( basic_stat | compound_stat );
 */
static gruntMemCell*
stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* basic_stat4;
    #undef	RETURN_TYPE_basic_stat4
    #define	RETURN_TYPE_basic_stat4 gruntMemCell*

    gruntMemCell* compound_stat5;
    #undef	RETURN_TYPE_compound_stat5
    #define	RETURN_TYPE_compound_stat5 gruntMemCell*

    /* Initialize rule variables
     */


    basic_stat4 = NULL;
    compound_stat5 = NULL;

    {
        {
            //  gruntEval.g:139:2: ( basic_stat | compound_stat )
            
            ANTLR3_UINT32 alt7;

            alt7=2;


            {
                int LA7_0 = LA(1);
                if ( (((LA7_0 >= OP_ASSIGN) && (LA7_0 <= COMMA_BLOCK)) || ((LA7_0 >= IF_STAT) && (LA7_0 <= SWITCH_STAT)) || ((LA7_0 >= FOR_STAT) && (LA7_0 <= DICT_VALUE)) || ((LA7_0 >= IDENTIFIER) && (LA7_0 <= STRING_LITERAL)) || ((LA7_0 >= DECIMAL_INTEGER_LITERAL) && (LA7_0 <= FLOAT_LITERAL))) ) 
                {
                    alt7=1;
                }
                else if ( (LA7_0 == CP_BLOCK) ) 
                {
                    alt7=2;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE; 
                        return value;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 7;
                    EXCEPTION->state        = 0;


                    goto rulestatEx;
                }
            }
            switch (alt7) 
            {
        	case 1:
        	    // gruntEval.g:139:4: basic_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_basic_stat_in_stat245);
        	        basic_stat4=basic_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= basic_stat4;
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:140:4: compound_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_compound_stat_in_stat254);
        	        compound_stat5=compound_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= compound_stat5;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatEx; /* Prevent compiler warnings */
    rulestatEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end stat */

/** 
 * $ANTLR start stat_no_scope
 * gruntEval.g:143:1: stat_no_scope returns [gruntMemCell* value = 0] : ( basic_stat | compound_stat_no_scope );
 */
static gruntMemCell*
stat_no_scope(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* basic_stat6;
    #undef	RETURN_TYPE_basic_stat6
    #define	RETURN_TYPE_basic_stat6 gruntMemCell*

    gruntMemCell* compound_stat_no_scope7;
    #undef	RETURN_TYPE_compound_stat_no_scope7
    #define	RETURN_TYPE_compound_stat_no_scope7 gruntMemCell*

    /* Initialize rule variables
     */


    basic_stat6 = NULL;
    compound_stat_no_scope7 = NULL;

    {
        {
            //  gruntEval.g:145:2: ( basic_stat | compound_stat_no_scope )
            
            ANTLR3_UINT32 alt8;

            alt8=2;


            {
                int LA8_0 = LA(1);
                if ( (((LA8_0 >= OP_ASSIGN) && (LA8_0 <= COMMA_BLOCK)) || ((LA8_0 >= IF_STAT) && (LA8_0 <= SWITCH_STAT)) || ((LA8_0 >= FOR_STAT) && (LA8_0 <= DICT_VALUE)) || ((LA8_0 >= IDENTIFIER) && (LA8_0 <= STRING_LITERAL)) || ((LA8_0 >= DECIMAL_INTEGER_LITERAL) && (LA8_0 <= FLOAT_LITERAL))) ) 
                {
                    alt8=1;
                }
                else if ( (LA8_0 == CP_BLOCK) ) 
                {
                    alt8=2;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE; 
                        return value;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 8;
                    EXCEPTION->state        = 0;


                    goto rulestat_no_scopeEx;
                }
            }
            switch (alt8) 
            {
        	case 1:
        	    // gruntEval.g:145:4: basic_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_basic_stat_in_stat_no_scope274);
        	        basic_stat6=basic_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestat_no_scopeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= basic_stat6;
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:146:4: compound_stat_no_scope
        	    {
        	        FOLLOWPUSH(FOLLOW_compound_stat_no_scope_in_stat_no_scope283);
        	        compound_stat_no_scope7=compound_stat_no_scope(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestat_no_scopeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= compound_stat_no_scope7;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestat_no_scopeEx; /* Prevent compiler warnings */
    rulestat_no_scopeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end stat_no_scope */

/** 
 * $ANTLR start compound_stat_no_scope
 * gruntEval.g:149:1: compound_stat_no_scope returns [gruntMemCell* value = 0] : ^( CP_BLOCK ( asnot )* ) ;
 */
static gruntMemCell*
compound_stat_no_scope(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		size_t cont_exec = 1;
    		gruntMemCell* ret = 0;
    	
    {
        // gruntEval.g:156:2: ( ^( CP_BLOCK ( asnot )* ) )
        // gruntEval.g:156:4: ^( CP_BLOCK ( asnot )* )
        {
             MATCHT(CP_BLOCK, &FOLLOW_CP_BLOCK_in_compound_stat_no_scope310); 
            if  (HASEXCEPTION())
            {
                goto rulecompound_stat_no_scopeEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecompound_stat_no_scopeEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

                // gruntEval.g:157:4: ( asnot )*

                for (;;)
                {
                    int alt9=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA9_0 = LA(1);
                        if ( (((LA9_0 >= OP_UNARY_MINUS) && (LA9_0 <= 134))) ) 
                        {
                            alt9=1;
                        }

                    }
                    switch (alt9) 
                    {
                	case 1:
                	    // gruntEval.g:158:4: asnot
                	    {
                	        if ( BACKTRACKING==0 ) 
                	        {

                	            				if(cont_exec)
                	            				{
                	            					ret = exec_rule(ctx, getCurNodeIndex(ctx), &stat);
                	            					if(ret)
                	            					{
                	            						if(ret->getType() == gruntMemCell::TYPE_FLOWCTRL /*currently, only break and continue for flow control*/ || ret->isReturnValue())
                	            						{
                	            							value= ret;
                	            							cont_exec = false;
                	            						}
                	            						else
                	            						{
                	            							Z_ASSERT( false );
                	            						}
                	            					}
                	            				}
                	            			
                	        }
                	        FOLLOWPUSH(FOLLOW_asnot_in_compound_stat_no_scope323);
                	        asnot(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecompound_stat_no_scopeEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop9;	/* break out of the loop */
                	    break;
                    }
                }
                loop9: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecompound_stat_no_scopeEx;
                }
                if (HASFAILED())
                {
                    return value;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecompound_stat_no_scopeEx; /* Prevent compiler warnings */
    rulecompound_stat_no_scopeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end compound_stat_no_scope */

/** 
 * $ANTLR start compound_stat
 * gruntEval.g:179:1: compound_stat returns [gruntMemCell* value = 0] : compound_stat_no_scope ;
 */
static gruntMemCell*
compound_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* compound_stat_no_scope8;
    #undef	RETURN_TYPE_compound_stat_no_scope8
    #define	RETURN_TYPE_compound_stat_no_scope8 gruntMemCell*

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    	
    compound_stat_no_scope8 = NULL;

    {
        // gruntEval.g:185:2: ( compound_stat_no_scope )
        // gruntEval.g:185:4: compound_stat_no_scope
        {
            if ( BACKTRACKING==0 ) 
            {
                runtime.enterScope(gruntMemCell::SCOPE_BLOCK);
            }
            FOLLOWPUSH(FOLLOW_compound_stat_no_scope_in_compound_stat354);
            compound_stat_no_scope8=compound_stat_no_scope(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecompound_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {
                value= compound_stat_no_scope8;
            }
            if ( BACKTRACKING==0 ) 
            {
                runtime.leaveScope();
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecompound_statEx; /* Prevent compiler warnings */
    rulecompound_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end compound_stat */

/** 
 * $ANTLR start local_declaration_stat
 * gruntEval.g:188:1: local_declaration_stat : ^( LOCAL_DECLARATION_STAT IDENTIFIER ( expr ) ) ;
 */
static void
local_declaration_stat(pgruntEval ctx)
{   
    pANTLR3_BASE_TREE    IDENTIFIER9;
    gruntMemCell* expr10;
    #undef	RETURN_TYPE_expr10
    #define	RETURN_TYPE_expr10 gruntMemCell*

    /* Initialize rule variables
     */



    		ANTLR3_INT32 e_index = -1;
    		gruntRuntime& runtime = *RUNTIME;
    	
    IDENTIFIER9       = NULL;
    expr10 = NULL;

    {
        // gruntEval.g:194:2: ( ^( LOCAL_DECLARATION_STAT IDENTIFIER ( expr ) ) )
        // gruntEval.g:194:4: ^( LOCAL_DECLARATION_STAT IDENTIFIER ( expr ) )
        {
             MATCHT(LOCAL_DECLARATION_STAT, &FOLLOW_LOCAL_DECLARATION_STAT_in_local_declaration_stat377); 
            if  (HASEXCEPTION())
            {
                goto rulelocal_declaration_statEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelocal_declaration_statEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            IDENTIFIER9 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_local_declaration_stat379); 
            if  (HASEXCEPTION())
            {
                goto rulelocal_declaration_statEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            // gruntEval.g:194:40: ( expr )
            // gruntEval.g:194:41: expr
            {
                if ( BACKTRACKING==0 ) 
                {
                    e_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_expr_in_local_declaration_stat384);
                expr10=expr(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulelocal_declaration_statEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelocal_declaration_statEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			gruntMemCell* c = runtime.addLocalCell((const wchar_t*)(IDENTIFIER9->getText(IDENTIFIER9))->chars);
                			if(e_index != -1)
                				runtime.op_assign(c, expr10);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelocal_declaration_statEx; /* Prevent compiler warnings */
    rulelocal_declaration_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end local_declaration_stat */

/** 
 * $ANTLR start function_definition
 * gruntEval.g:202:1: function_definition returns [gruntMemCell* value] : ^( FUNC_DEF ( asnot )* ) ;
 */
static gruntMemCell*
function_definition(pgruntEval ctx)
{   
    gruntMemCell* value = NULL;

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    	
    {
        // gruntEval.g:208:2: ( ^( FUNC_DEF ( asnot )* ) )
        // gruntEval.g:208:4: ^( FUNC_DEF ( asnot )* )
        {
            if ( BACKTRACKING==0 ) 
            {
                value= runtime.addTempCell(); value->asFunction() = (int32_t)getCurNodeIndex(ctx);
            }
             MATCHT(FUNC_DEF, &FOLLOW_FUNC_DEF_in_function_definition416); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_definitionEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_definitionEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

                // gruntEval.g:208:103: ( asnot )*

                for (;;)
                {
                    int alt10=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA10_0 = LA(1);
                        if ( (((LA10_0 >= OP_UNARY_MINUS) && (LA10_0 <= 134))) ) 
                        {
                            alt10=1;
                        }

                    }
                    switch (alt10) 
                    {
                	case 1:
                	    // gruntEval.g:208:103: asnot
                	    {
                	        FOLLOWPUSH(FOLLOW_asnot_in_function_definition418);
                	        asnot(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_definitionEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop10;	/* break out of the loop */
                	    break;
                    }
                }
                loop10: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_definitionEx;
                }
                if (HASFAILED())
                {
                    return value;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunction_definitionEx; /* Prevent compiler warnings */
    rulefunction_definitionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end function_definition */

/** 
 * $ANTLR start get_func_def
 * gruntEval.g:211:1: get_func_def returns [ANTLR3_INT32 param_start, ANTLR3_INT32 param_end, ANTLR3_INT32 block_index] : ^( FUNC_DEF parameter_list ( asnot ) ) ;
 */
static gruntEval_get_func_def_return
get_func_def(pgruntEval ctx)
{   
    gruntEval_get_func_def_return retval;

    gruntEval_parameter_list_return parameter_list11;
    #undef	RETURN_TYPE_parameter_list11
    #define	RETURN_TYPE_parameter_list11 gruntEval_parameter_list_return

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // gruntEval.g:213:2: ( ^( FUNC_DEF parameter_list ( asnot ) ) )
        // gruntEval.g:213:4: ^( FUNC_DEF parameter_list ( asnot ) )
        {
             MATCHT(FUNC_DEF, &FOLLOW_FUNC_DEF_in_get_func_def437); 
            if  (HASEXCEPTION())
            {
                goto ruleget_func_defEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleget_func_defEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_parameter_list_in_get_func_def439);
            parameter_list11=parameter_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleget_func_defEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            // gruntEval.g:213:30: ( asnot )
            // gruntEval.g:213:31: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    retval.block_index= getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_get_func_def444);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleget_func_defEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleget_func_defEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {

                			retval.param_start= parameter_list11.param_start;
                			retval.param_end= parameter_list11.param_end;
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleget_func_defEx; /* Prevent compiler warnings */
    ruleget_func_defEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end get_func_def */

/** 
 * $ANTLR start parameter_list
 * gruntEval.g:220:1: parameter_list returns [int32_t param_start, int32_t param_end] : ^( PARAMETER_LIST ( IDENTIFIER )* ) ;
 */
static gruntEval_parameter_list_return
parameter_list(pgruntEval ctx)
{   
    gruntEval_parameter_list_return retval;

    /* Initialize rule variables
     */



    		retval.param_start= 0x7fffffff;
    		retval.param_end= 0x80000000;
    	
    retval.start = LT(1); retval.stop = retval.start;

    {
        // gruntEval.g:227:2: ( ^( PARAMETER_LIST ( IDENTIFIER )* ) )
        // gruntEval.g:227:4: ^( PARAMETER_LIST ( IDENTIFIER )* )
        {
             MATCHT(PARAMETER_LIST, &FOLLOW_PARAMETER_LIST_in_parameter_list474); 
            if  (HASEXCEPTION())
            {
                goto ruleparameter_listEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparameter_listEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // gruntEval.g:227:21: ( IDENTIFIER )*

                for (;;)
                {
                    int alt11=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA11_0 = LA(1);
                        if ( (LA11_0 == IDENTIFIER) ) 
                        {
                            alt11=1;
                        }

                    }
                    switch (alt11) 
                    {
                	case 1:
                	    // gruntEval.g:227:22: IDENTIFIER
                	    {
                	        if ( BACKTRACKING==0 ) 
                	        {
                	            retval.param_start= min(retval.param_start, (int32_t)getCurNodeIndex(ctx));
                	        }
                	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parameter_list479); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleparameter_listEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */

                if ( BACKTRACKING==0 ) 
                {
                    retval.param_end= (int32_t)getCurNodeIndex(ctx);
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparameter_listEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameter_listEx; /* Prevent compiler warnings */
    ruleparameter_listEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end parameter_list */

/** 
 * $ANTLR start selection_stat
 * gruntEval.g:230:1: selection_stat returns [gruntMemCell* value = 0] : ( if_stat | switch_stat );
 */
static gruntMemCell*
selection_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* if_stat12;
    #undef	RETURN_TYPE_if_stat12
    #define	RETURN_TYPE_if_stat12 gruntMemCell*

    gruntMemCell* switch_stat13;
    #undef	RETURN_TYPE_switch_stat13
    #define	RETURN_TYPE_switch_stat13 gruntMemCell*

    /* Initialize rule variables
     */


    if_stat12 = NULL;
    switch_stat13 = NULL;

    {
        {
            //  gruntEval.g:232:2: ( if_stat | switch_stat )
            
            ANTLR3_UINT32 alt12;

            alt12=2;


            {
                int LA12_0 = LA(1);
                if ( (LA12_0 == IF_STAT) ) 
                {
                    alt12=1;
                }
                else if ( (LA12_0 == SWITCH_STAT) ) 
                {
                    alt12=2;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE; 
                        return value;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleselection_statEx;
                }
            }
            switch (alt12) 
            {
        	case 1:
        	    // gruntEval.g:232:4: if_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_if_stat_in_selection_stat500);
        	        if_stat12=if_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselection_statEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= if_stat12;
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:233:4: switch_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_switch_stat_in_selection_stat508);
        	        switch_stat13=switch_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselection_statEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= switch_stat13;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleselection_statEx; /* Prevent compiler warnings */
    ruleselection_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end selection_stat */

/** 
 * $ANTLR start switch_stat
 * gruntEval.g:236:1: switch_stat returns [gruntMemCell* value = 0] : ^( SWITCH_STAT e= expr ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL ( asnot ) ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* ) ;
 */
static gruntMemCell*
switch_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e gruntMemCell*

    /* Initialize rule variables
     */



    		ANTLR3_INT32 ce_index = -1;
    		ANTLR3_INT32 def_index = -1;
    		size_t switched = 0;
    		size_t broken = 0;
    		gruntMemCell* expr_value;
    		gruntRuntime& runtime = *RUNTIME;
    	
    e = NULL;

    {
        // gruntEval.g:247:2: ( ^( SWITCH_STAT e= expr ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL ( asnot ) ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* ) )
        // gruntEval.g:247:4: ^( SWITCH_STAT e= expr ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL ( asnot ) ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* )
        {
             MATCHT(SWITCH_STAT, &FOLLOW_SWITCH_STAT_in_switch_stat534); 
            if  (HASEXCEPTION())
            {
                goto ruleswitch_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( BACKTRACKING==0 ) 
            {
                runtime.enterScope(gruntMemCell::SCOPE_SWITCH);
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleswitch_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_expr_in_switch_stat542);
            e=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleswitch_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {
                expr_value = e;
            }

            // gruntEval.g:248:4: ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL ( asnot ) ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )*

            for (;;)
            {
                int alt13=4;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA13_0 = LA(1);
                    if ( (LA13_0 == SWITCH_CASE_LABEL) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA13_2 = LA(2);
                            if ( (LA13_2 == DOWN) && (synpred1_gruntEval(ctx))) 
                            {
                                alt13=1;
                            }
                            else if ( (synpred2_gruntEval(ctx)) ) 
                            {
                                alt13=2;
                            }
                            else if ( (ANTLR3_TRUE) ) 
                            {
                                alt13=3;
                            }

                        }
                    }
                    else if ( (((LA13_0 >= OP_UNARY_MINUS) && (LA13_0 <= SWITCH_STAT)) || ((LA13_0 >= FOR_STAT) && (LA13_0 <= 134))) ) 
                    {
                        alt13=3;
                    }

                }
                switch (alt13) 
                {
            	case 1:
            	    // gruntEval.g:249:5: ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL ( asnot ) )
            	    {
            	         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_switch_stat566); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        // gruntEval.g:249:57: ( asnot )
            	        // gruntEval.g:249:58: asnot
            	        {
            	            if ( BACKTRACKING==0 ) 
            	            {
            	                if(!switched){ce_index = getCurNodeIndex(ctx); if(runtime.op_equal(expr_value, exec_rule(ctx, ce_index, &expr))->toBool()) switched = 1;}
            	            }
            	            FOLLOWPUSH(FOLLOW_asnot_in_switch_stat571);
            	            asnot(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleswitch_statEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return value;
            	            }

            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 2:
            	    // gruntEval.g:250:6: ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL
            	    {
            	         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_switch_stat586); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            def_index = getCurNodeIndex(ctx);
            	        }

            	    }
            	    break;
            	case 3:
            	    // gruntEval.g:251:6: ( asnot )
            	    {
            	        // gruntEval.g:251:6: ( asnot )
            	        // gruntEval.g:252:6: asnot
            	        {
            	            if ( BACKTRACKING==0 ) 
            	            {

            	                						if(switched && !broken)
            	                						{
            	                							if(!exec_in_switch_block(ctx, getCurNodeIndex(ctx), value))
            	                								broken = 1;
            	                						}
            	                					
            	            }
            	            FOLLOWPUSH(FOLLOW_asnot_in_switch_stat608);
            	            asnot(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleswitch_statEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return value;
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                if(!switched && def_index != -1){value= exec_rule(ctx, def_index, &switch_default_exec);}
            }
            if ( BACKTRACKING==0 ) 
            {
                runtime.leaveScope();
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleswitch_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleswitch_statEx; /* Prevent compiler warnings */
    ruleswitch_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end switch_stat */

/** 
 * $ANTLR start switch_default_exec
 * gruntEval.g:266:1: switch_default_exec returns [gruntMemCell* value = 0] : ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL asnot ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* UP ;
 */
static gruntMemCell*
switch_default_exec(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		size_t broken = 0;
    	
    {
        // gruntEval.g:272:2: ( ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL asnot ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* UP )
        // gruntEval.g:272:4: ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL asnot ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )* UP
        {

            // gruntEval.g:272:4: ( ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL asnot ) | ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL | ( asnot ) )*

            for (;;)
            {
                int alt14=4;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA14_0 = LA(1);
                    if ( (LA14_0 == SWITCH_CASE_LABEL) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA14_2 = LA(2);
                            if ( (LA14_2 == DOWN) && (synpred3_gruntEval(ctx))) 
                            {
                                alt14=1;
                            }
                            else if ( (synpred4_gruntEval(ctx)) ) 
                            {
                                alt14=2;
                            }
                            else if ( (ANTLR3_TRUE) ) 
                            {
                                alt14=3;
                            }

                        }
                    }
                    else if ( (((LA14_0 >= OP_UNARY_MINUS) && (LA14_0 <= SWITCH_STAT)) || ((LA14_0 >= FOR_STAT) && (LA14_0 <= 134))) ) 
                    {
                        alt14=3;
                    }

                }
                switch (alt14) 
                {
            	case 1:
            	    // gruntEval.g:273:4: ( ^( SWITCH_CASE_LABEL asnot ) )=> ^( SWITCH_CASE_LABEL asnot )
            	    {
            	         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec668); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_default_execEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_default_execEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        FOLLOWPUSH(FOLLOW_asnot_in_switch_default_exec670);
            	        asnot(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_default_execEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_default_execEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 2:
            	    // gruntEval.g:274:5: ( SWITCH_CASE_LABEL )=> SWITCH_CASE_LABEL
            	    {
            	         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_switch_default_exec683); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitch_default_execEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;
            	case 3:
            	    // gruntEval.g:275:5: ( asnot )
            	    {
            	        // gruntEval.g:275:5: ( asnot )
            	        // gruntEval.g:276:5: asnot
            	        {
            	            if ( BACKTRACKING==0 ) 
            	            {

            	                					if(!broken)
            	                					{
            	                						if(!exec_in_switch_block(ctx, getCurNodeIndex(ctx), value))
            	                							broken = 1;
            	                					}
            	                				
            	            }
            	            FOLLOWPUSH(FOLLOW_asnot_in_switch_default_exec700);
            	            asnot(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleswitch_default_execEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return value;
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */

             MATCHT(UP, &FOLLOW_UP_in_switch_default_exec708); 
            if  (HASEXCEPTION())
            {
                goto ruleswitch_default_execEx;
            }
            if (HASFAILED())
            {
                return value;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleswitch_default_execEx; /* Prevent compiler warnings */
    ruleswitch_default_execEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end switch_default_exec */

/** 
 * $ANTLR start if_stat
 * gruntEval.g:287:1: if_stat returns [gruntMemCell* value = 0] : ^( IF_STAT ( asnot ) ( asnot ) ( asnot )? ) ;
 */
static gruntMemCell*
if_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		ANTLR3_INT32 c_index = -1, t_index = -1, f_index = -1;
    	
    {
        // gruntEval.g:293:2: ( ^( IF_STAT ( asnot ) ( asnot ) ( asnot )? ) )
        // gruntEval.g:293:4: ^( IF_STAT ( asnot ) ( asnot ) ( asnot )? )
        {
             MATCHT(IF_STAT, &FOLLOW_IF_STAT_in_if_stat732); 
            if  (HASEXCEPTION())
            {
                goto ruleif_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleif_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:293:14: ( asnot )
            // gruntEval.g:293:15: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    c_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_if_stat737);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleif_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:293:56: ( asnot )
            // gruntEval.g:293:57: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    t_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_if_stat743);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleif_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            // gruntEval.g:293:98: ( asnot )?
            {
                int alt15=2;
                {
                    int LA15_0 = LA(1);
                    if ( (((LA15_0 >= OP_UNARY_MINUS) && (LA15_0 <= 134))) ) 
                    {
                        alt15=1;
                    }
                }
                switch (alt15) 
                {
            	case 1:
            	    // gruntEval.g:293:99: asnot
            	    {
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            f_index = getCurNodeIndex(ctx);
            	        }
            	        FOLLOWPUSH(FOLLOW_asnot_in_if_stat749);
            	        asnot(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_statEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleif_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			gruntMemCell* v = exec_rule(ctx, c_index, &expr);
                			if(v->toBool())
                			{
                				value= exec_rule(ctx, t_index, &stat);
                			}
                			else if(f_index != -1)
                			{
                				value= exec_rule(ctx, f_index, &stat);
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleif_statEx; /* Prevent compiler warnings */
    ruleif_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end if_stat */

/** 
 * $ANTLR start iteration_stat
 * gruntEval.g:307:1: iteration_stat returns [gruntMemCell* value = 0] : ( for_stat | while_stat | do_while_stat );
 */
static gruntMemCell*
iteration_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    gruntMemCell* for_stat14;
    #undef	RETURN_TYPE_for_stat14
    #define	RETURN_TYPE_for_stat14 gruntMemCell*

    gruntMemCell* while_stat15;
    #undef	RETURN_TYPE_while_stat15
    #define	RETURN_TYPE_while_stat15 gruntMemCell*

    gruntMemCell* do_while_stat16;
    #undef	RETURN_TYPE_do_while_stat16
    #define	RETURN_TYPE_do_while_stat16 gruntMemCell*

    /* Initialize rule variables
     */


    for_stat14 = NULL;
    while_stat15 = NULL;
    do_while_stat16 = NULL;

    {
        {
            //  gruntEval.g:309:2: ( for_stat | while_stat | do_while_stat )
            
            ANTLR3_UINT32 alt16;

            alt16=3;

            switch ( LA(1) ) 
            {
            case FOR_STAT:
            	{
            		alt16=1;
            	}
                break;
            case WHILE_STAT:
            	{
            		alt16=2;
            	}
                break;
            case DO_WHILE_STAT:
            	{
            		alt16=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return value;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruleiteration_statEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // gruntEval.g:309:4: for_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_for_stat_in_iteration_stat772);
        	        for_stat14=for_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteration_statEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= for_stat14;
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:310:4: while_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_while_stat_in_iteration_stat779);
        	        while_stat15=while_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteration_statEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= while_stat15;
        	        }

        	    }
        	    break;
        	case 3:
        	    // gruntEval.g:311:4: do_while_stat
        	    {
        	        FOLLOWPUSH(FOLLOW_do_while_stat_in_iteration_stat786);
        	        do_while_stat16=do_while_stat(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleiteration_statEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= do_while_stat16;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleiteration_statEx; /* Prevent compiler warnings */
    ruleiteration_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end iteration_stat */

/** 
 * $ANTLR start do_while_stat
 * gruntEval.g:314:1: do_while_stat returns [gruntMemCell* value = 0] : ^( DO_WHILE_STAT ( asnot ) ( asnot ) ) ;
 */
static gruntMemCell*
do_while_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		ANTLR3_INT32 c_index, s_index;
    		gruntMemCell* ret = 0;
    		gruntRuntime& runtime = *RUNTIME;
    	
    {
        // gruntEval.g:322:2: ( ^( DO_WHILE_STAT ( asnot ) ( asnot ) ) )
        // gruntEval.g:322:4: ^( DO_WHILE_STAT ( asnot ) ( asnot ) )
        {
             MATCHT(DO_WHILE_STAT, &FOLLOW_DO_WHILE_STAT_in_do_while_stat812); 
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:322:20: ( asnot )
            // gruntEval.g:322:21: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    s_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_do_while_stat817);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruledo_while_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:322:62: ( asnot )
            // gruntEval.g:322:63: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    c_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_do_while_stat823);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruledo_while_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruledo_while_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			runtime.enterScope(gruntMemCell::SCOPE_ITERATION);
                			do
                			{
                				ret = exec_rule(ctx, s_index, &compound_stat_no_scope);
                				if(ret)
                				{
                					if(ret->getType() == gruntMemCell::TYPE_FLOWCTRL)
                					{
                						if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_BREAK)
                							break;
                						else if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_CONTINUE)
                						{// intentionally empty
                						}
                						else
                						{
                							Z_ASSERT( false );
                						}
                					}
                					else if(ret->isReturnValue())
                					{
                						value= ret;
                						break;
                					}
                					else
                					{
                						Z_ASSERT( false );
                					}
                				}
                			}while(exec_rule(ctx, c_index, &expr)->toBool());
                			runtime.leaveScope();
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledo_while_statEx; /* Prevent compiler warnings */
    ruledo_while_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end do_while_stat */

/** 
 * $ANTLR start while_stat
 * gruntEval.g:357:1: while_stat returns [gruntMemCell* value = 0] : ^( WHILE_STAT ( asnot ) ( asnot ) ) ;
 */
static gruntMemCell*
while_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		ANTLR3_INT32 c_index, s_index;
    		gruntMemCell* ret = 0;
    		gruntRuntime& runtime = *RUNTIME;
    	
    {
        // gruntEval.g:365:2: ( ^( WHILE_STAT ( asnot ) ( asnot ) ) )
        // gruntEval.g:365:4: ^( WHILE_STAT ( asnot ) ( asnot ) )
        {
             MATCHT(WHILE_STAT, &FOLLOW_WHILE_STAT_in_while_stat853); 
            if  (HASEXCEPTION())
            {
                goto rulewhile_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewhile_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:365:17: ( asnot )
            // gruntEval.g:365:18: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    c_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_while_stat858);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulewhile_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:365:59: ( asnot )
            // gruntEval.g:365:60: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    s_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_while_stat864);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulewhile_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewhile_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			runtime.enterScope(gruntMemCell::SCOPE_ITERATION);
                			for(;;)
                			{
                				if(!exec_rule(ctx, c_index, &expr)->toBool())
                				{
                					break;
                				}
                				ret = exec_rule(ctx, s_index, &stat_no_scope);
                				if(ret)
                				{
                					if(ret->getType() == gruntMemCell::TYPE_FLOWCTRL)
                					{
                						if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_BREAK)
                							break;
                						else if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_CONTINUE)
                						{// intentionally empty
                						}
                						else
                						{
                							Z_ASSERT( false );
                						}
                					}
                					else if(ret->isReturnValue())
                					{
                						value= ret;
                						break;
                					}
                					else
                					{
                						Z_ASSERT( false );
                					}
                				}
                			}
                			runtime.leaveScope();
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewhile_statEx; /* Prevent compiler warnings */
    rulewhile_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end while_stat */

/** 
 * $ANTLR start for_stat
 * gruntEval.g:404:1: for_stat returns [gruntMemCell* value = 0] : ^( FOR_STAT ( asnot ) ( asnot ) ( asnot ) ( asnot ) ) ;
 */
static gruntMemCell*
for_stat(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    /* Initialize rule variables
     */



    		ANTLR3_INT32 i_index, c_index, l_index, s_index;
    		gruntMemCell* ret = 0;
    		gruntRuntime& runtime = *RUNTIME;
    	
    {
        // gruntEval.g:412:2: ( ^( FOR_STAT ( asnot ) ( asnot ) ( asnot ) ( asnot ) ) )
        // gruntEval.g:412:4: ^( FOR_STAT ( asnot ) ( asnot ) ( asnot ) ( asnot ) )
        {
             MATCHT(FOR_STAT, &FOLLOW_FOR_STAT_in_for_stat894); 
            if  (HASEXCEPTION())
            {
                goto rulefor_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefor_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:412:15: ( asnot )
            // gruntEval.g:412:16: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    i_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_for_stat899);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulefor_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:412:57: ( asnot )
            // gruntEval.g:412:58: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    c_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_for_stat905);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulefor_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:412:99: ( asnot )
            // gruntEval.g:412:100: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    l_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_for_stat911);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulefor_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:412:141: ( asnot )
            // gruntEval.g:412:142: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    s_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_for_stat917);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulefor_statEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefor_statEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			runtime.enterScope(gruntMemCell::SCOPE_ITERATION);

                			ret = exec_rule(ctx, i_index, &stat);
                			Z_ASSERT( !ret );

                			for(;;)
                			{
                				gruntMemCell* v = exec_rule(ctx, c_index, &expr);
                				if(v->toBool())
                				{
                					runtime.clearTemp();
                					ret = exec_rule(ctx, s_index, &stat_no_scope);
                					if(ret)
                					{
                						if(ret->getType() == gruntMemCell::TYPE_FLOWCTRL)
                						{
                							if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_BREAK)
                							{
                								ret->getPool()->deleteCell(ret->getIndex());
                								break;
                							}
                							else if(ret->toFlowCtrl() == gruntMemCell::FLOWCTRL_CONTINUE)
                							{
                								ret->getPool()->deleteCell(ret->getIndex());
                							}
                							else
                							{
                								Z_ASSERT( false );
                							}
                						}
                						else if(ret->isReturnValue())
                						{
                							value= ret;
                							break;
                						}
                					}

                					exec_rule(ctx, l_index, &stat);
                				}
                				else
                					break;
                			}
                			runtime.leaveScope();
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefor_statEx; /* Prevent compiler warnings */
    rulefor_statEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end for_stat */

/** 
 * $ANTLR start expr
 * gruntEval.g:460:1: expr returns [gruntMemCell* value = 0] : ( EMPTY_EXPR | conditional_expr | ^( OP_ASSIGN e0= expr e1= expr ) | ^( OP_ADD_ASSIGN e0= expr e1= expr ) | ^( OP_SUB_ASSIGN e0= expr e1= expr ) | ^( OP_MUL_ASSIGN e0= expr e1= expr ) | ^( OP_DIV_ASSIGN e0= expr e1= expr ) | ^( OP_MOD_ASSIGN e0= expr e1= expr ) | ^( OP_SHIFT_LEFT_ASSIGN e0= expr e1= expr ) | ^( OP_SHIFT_RIGHT_ASSIGN e0= expr e1= expr ) | ^( OP_AND_ASSIGN e0= expr e1= expr ) | ^( OP_OR_ASSIGN e0= expr e1= expr ) | ^( OP_XOR_ASSIGN e0= expr e1= expr ) | ^( OP_LOGICAL_OR e0= expr e1= expr ) | ^( OP_LOGICAL_AND e0= expr e1= expr ) | ^( OP_BITWISE_OR e0= expr e1= expr ) | ^( OP_BITWISE_XOR e0= expr e1= expr ) | ^( OP_BITWISE_AND e0= expr e1= expr ) | ^( OP_EQUAL e0= expr e1= expr ) | ^( OP_NOT_EQUAL e0= expr e1= expr ) | ^( OP_LESS e0= expr e1= expr ) | ^( OP_LESS_EQUAL e0= expr e1= expr ) | ^( OP_GREATER e0= expr e1= expr ) | ^( OP_GREATER_EQUAL e0= expr e1= expr ) | ^( OP_SHIFT_LEFT e0= expr e1= expr ) | ^( OP_SHIFT_RIGHT e0= expr e1= expr ) | ^( OP_ADD e0= expr e1= expr ) | ^( OP_SUB e0= expr e1= expr ) | ^( OP_MOD e0= expr e1= expr ) | ^( OP_MUL e0= expr e1= expr ) | ^( OP_DIV e0= expr e1= expr ) | ^( OP_BITWISE_NOT e0= expr ) | ^( OP_LOGICAL_NOT e0= expr ) | ^( OP_NEGATE e0= expr ) | ^( OP_PRE_INCR e0= expr ) | ^( OP_PRE_DECR e0= expr ) | ^( OP_POST_INCR e0= expr ) | ^( OP_POST_DECR e0= expr ) | ^( OP_ELEMENT e0= expr IDENTIFIER ) | ^( OP_INDEX e0= expr e1= expr ) | call_func_expr | STRING_LITERAL | DECIMAL_INTEGER_LITERAL | HEXADECIMAL_INTEGER_LITERAL | FLOAT_LITERAL | IDENTIFIER | function_definition | THIS_FUNC | dictionary_value );
 */
static gruntMemCell*
expr(pgruntEval ctx)
{   
    gruntMemCell* value =  0;

    pANTLR3_BASE_TREE    IDENTIFIER18;
    pANTLR3_BASE_TREE    STRING_LITERAL20;
    pANTLR3_BASE_TREE    DECIMAL_INTEGER_LITERAL21;
    pANTLR3_BASE_TREE    FLOAT_LITERAL22;
    pANTLR3_BASE_TREE    IDENTIFIER23;
    gruntMemCell* e0;
    #undef	RETURN_TYPE_e0
    #define	RETURN_TYPE_e0 gruntMemCell*

    gruntMemCell* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 gruntMemCell*

    gruntMemCell* conditional_expr17;
    #undef	RETURN_TYPE_conditional_expr17
    #define	RETURN_TYPE_conditional_expr17 gruntMemCell*

    gruntMemCell* call_func_expr19;
    #undef	RETURN_TYPE_call_func_expr19
    #define	RETURN_TYPE_call_func_expr19 gruntMemCell*

    gruntMemCell* function_definition24;
    #undef	RETURN_TYPE_function_definition24
    #define	RETURN_TYPE_function_definition24 gruntMemCell*

    gruntMemCell* dictionary_value25;
    #undef	RETURN_TYPE_dictionary_value25
    #define	RETURN_TYPE_dictionary_value25 gruntMemCell*

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    	
    IDENTIFIER18       = NULL;
    STRING_LITERAL20       = NULL;
    DECIMAL_INTEGER_LITERAL21       = NULL;
    FLOAT_LITERAL22       = NULL;
    IDENTIFIER23       = NULL;
    e0 = NULL;
    e1 = NULL;
    conditional_expr17 = NULL;
    call_func_expr19 = NULL;
    function_definition24 = NULL;
    dictionary_value25 = NULL;

    {
        {
            //  gruntEval.g:466:2: ( EMPTY_EXPR | conditional_expr | ^( OP_ASSIGN e0= expr e1= expr ) | ^( OP_ADD_ASSIGN e0= expr e1= expr ) | ^( OP_SUB_ASSIGN e0= expr e1= expr ) | ^( OP_MUL_ASSIGN e0= expr e1= expr ) | ^( OP_DIV_ASSIGN e0= expr e1= expr ) | ^( OP_MOD_ASSIGN e0= expr e1= expr ) | ^( OP_SHIFT_LEFT_ASSIGN e0= expr e1= expr ) | ^( OP_SHIFT_RIGHT_ASSIGN e0= expr e1= expr ) | ^( OP_AND_ASSIGN e0= expr e1= expr ) | ^( OP_OR_ASSIGN e0= expr e1= expr ) | ^( OP_XOR_ASSIGN e0= expr e1= expr ) | ^( OP_LOGICAL_OR e0= expr e1= expr ) | ^( OP_LOGICAL_AND e0= expr e1= expr ) | ^( OP_BITWISE_OR e0= expr e1= expr ) | ^( OP_BITWISE_XOR e0= expr e1= expr ) | ^( OP_BITWISE_AND e0= expr e1= expr ) | ^( OP_EQUAL e0= expr e1= expr ) | ^( OP_NOT_EQUAL e0= expr e1= expr ) | ^( OP_LESS e0= expr e1= expr ) | ^( OP_LESS_EQUAL e0= expr e1= expr ) | ^( OP_GREATER e0= expr e1= expr ) | ^( OP_GREATER_EQUAL e0= expr e1= expr ) | ^( OP_SHIFT_LEFT e0= expr e1= expr ) | ^( OP_SHIFT_RIGHT e0= expr e1= expr ) | ^( OP_ADD e0= expr e1= expr ) | ^( OP_SUB e0= expr e1= expr ) | ^( OP_MOD e0= expr e1= expr ) | ^( OP_MUL e0= expr e1= expr ) | ^( OP_DIV e0= expr e1= expr ) | ^( OP_BITWISE_NOT e0= expr ) | ^( OP_LOGICAL_NOT e0= expr ) | ^( OP_NEGATE e0= expr ) | ^( OP_PRE_INCR e0= expr ) | ^( OP_PRE_DECR e0= expr ) | ^( OP_POST_INCR e0= expr ) | ^( OP_POST_DECR e0= expr ) | ^( OP_ELEMENT e0= expr IDENTIFIER ) | ^( OP_INDEX e0= expr e1= expr ) | call_func_expr | STRING_LITERAL | DECIMAL_INTEGER_LITERAL | HEXADECIMAL_INTEGER_LITERAL | FLOAT_LITERAL | IDENTIFIER | function_definition | THIS_FUNC | dictionary_value )
            
            ANTLR3_UINT32 alt17;

            alt17=49;

            switch ( LA(1) ) 
            {
            case EMPTY_EXPR:
            	{
            		alt17=1;
            	}
                break;
            case OP_CONDITIONAL:
            	{
            		alt17=2;
            	}
                break;
            case OP_ASSIGN:
            	{
            		alt17=3;
            	}
                break;
            case OP_ADD_ASSIGN:
            	{
            		alt17=4;
            	}
                break;
            case OP_SUB_ASSIGN:
            	{
            		alt17=5;
            	}
                break;
            case OP_MUL_ASSIGN:
            	{
            		alt17=6;
            	}
                break;
            case OP_DIV_ASSIGN:
            	{
            		alt17=7;
            	}
                break;
            case OP_MOD_ASSIGN:
            	{
            		alt17=8;
            	}
                break;
            case OP_SHIFT_LEFT_ASSIGN:
            	{
            		alt17=9;
            	}
                break;
            case OP_SHIFT_RIGHT_ASSIGN:
            	{
            		alt17=10;
            	}
                break;
            case OP_AND_ASSIGN:
            	{
            		alt17=11;
            	}
                break;
            case OP_OR_ASSIGN:
            	{
            		alt17=12;
            	}
                break;
            case OP_XOR_ASSIGN:
            	{
            		alt17=13;
            	}
                break;
            case OP_LOGICAL_OR:
            	{
            		alt17=14;
            	}
                break;
            case OP_LOGICAL_AND:
            	{
            		alt17=15;
            	}
                break;
            case OP_BITWISE_OR:
            	{
            		alt17=16;
            	}
                break;
            case OP_BITWISE_XOR:
            	{
            		alt17=17;
            	}
                break;
            case OP_BITWISE_AND:
            	{
            		alt17=18;
            	}
                break;
            case OP_EQUAL:
            	{
            		alt17=19;
            	}
                break;
            case OP_NOT_EQUAL:
            	{
            		alt17=20;
            	}
                break;
            case OP_LESS:
            	{
            		alt17=21;
            	}
                break;
            case OP_LESS_EQUAL:
            	{
            		alt17=22;
            	}
                break;
            case OP_GREATER:
            	{
            		alt17=23;
            	}
                break;
            case OP_GREATER_EQUAL:
            	{
            		alt17=24;
            	}
                break;
            case OP_SHIFT_LEFT:
            	{
            		alt17=25;
            	}
                break;
            case OP_SHIFT_RIGHT:
            	{
            		alt17=26;
            	}
                break;
            case OP_ADD:
            	{
            		alt17=27;
            	}
                break;
            case OP_SUB:
            	{
            		alt17=28;
            	}
                break;
            case OP_MOD:
            	{
            		alt17=29;
            	}
                break;
            case OP_MUL:
            	{
            		alt17=30;
            	}
                break;
            case OP_DIV:
            	{
            		alt17=31;
            	}
                break;
            case OP_BITWISE_NOT:
            	{
            		alt17=32;
            	}
                break;
            case OP_LOGICAL_NOT:
            	{
            		alt17=33;
            	}
                break;
            case OP_NEGATE:
            	{
            		alt17=34;
            	}
                break;
            case OP_PRE_INCR:
            	{
            		alt17=35;
            	}
                break;
            case OP_PRE_DECR:
            	{
            		alt17=36;
            	}
                break;
            case OP_POST_INCR:
            	{
            		alt17=37;
            	}
                break;
            case OP_POST_DECR:
            	{
            		alt17=38;
            	}
                break;
            case OP_ELEMENT:
            	{
            		alt17=39;
            	}
                break;
            case OP_INDEX:
            	{
            		alt17=40;
            	}
                break;
            case OP_CALL_FUNC:
            	{
            		alt17=41;
            	}
                break;
            case STRING_LITERAL:
            	{
            		alt17=42;
            	}
                break;
            case DECIMAL_INTEGER_LITERAL:
            	{
            		alt17=43;
            	}
                break;
            case HEXADECIMAL_INTEGER_LITERAL:
            	{
            		alt17=44;
            	}
                break;
            case FLOAT_LITERAL:
            	{
            		alt17=45;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt17=46;
            	}
                break;
            case FUNC_DEF:
            	{
            		alt17=47;
            	}
                break;
            case THIS_FUNC:
            	{
            		alt17=48;
            	}
                break;
            case DICT_VALUE:
            	{
            		alt17=49;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return value;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruleexprEx;
            }

            switch (alt17) 
            {
        	case 1:
        	    // gruntEval.g:466:4: EMPTY_EXPR
        	    {
        	         MATCHT(EMPTY_EXPR, &FOLLOW_EMPTY_EXPR_in_expr946); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.addTempCell(); value->asInteger() = 1;
        	        }

        	    }
        	    break;
        	case 2:
        	    // gruntEval.g:467:4: conditional_expr
        	    {
        	        FOLLOWPUSH(FOLLOW_conditional_expr_in_expr957);
        	        conditional_expr17=conditional_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= conditional_expr17;
        	        }

        	    }
        	    break;
        	case 3:
        	    // gruntEval.g:468:4: ^( OP_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_ASSIGN, &FOLLOW_OP_ASSIGN_in_expr968); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr972);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr976);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 4:
        	    // gruntEval.g:469:4: ^( OP_ADD_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_ADD_ASSIGN, &FOLLOW_OP_ADD_ASSIGN_in_expr987); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr991);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr995);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_add_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 5:
        	    // gruntEval.g:470:4: ^( OP_SUB_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SUB_ASSIGN, &FOLLOW_OP_SUB_ASSIGN_in_expr1005); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1009);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1013);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_sub_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 6:
        	    // gruntEval.g:471:4: ^( OP_MUL_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_MUL_ASSIGN, &FOLLOW_OP_MUL_ASSIGN_in_expr1023); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1027);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1031);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_mul_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 7:
        	    // gruntEval.g:472:4: ^( OP_DIV_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_DIV_ASSIGN, &FOLLOW_OP_DIV_ASSIGN_in_expr1041); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1045);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1049);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_div_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 8:
        	    // gruntEval.g:473:4: ^( OP_MOD_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_MOD_ASSIGN, &FOLLOW_OP_MOD_ASSIGN_in_expr1059); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1063);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1067);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_mod_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 9:
        	    // gruntEval.g:474:4: ^( OP_SHIFT_LEFT_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SHIFT_LEFT_ASSIGN, &FOLLOW_OP_SHIFT_LEFT_ASSIGN_in_expr1077); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1081);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1085);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_shift_left_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 10:
        	    // gruntEval.g:475:4: ^( OP_SHIFT_RIGHT_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SHIFT_RIGHT_ASSIGN, &FOLLOW_OP_SHIFT_RIGHT_ASSIGN_in_expr1095); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1099);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1103);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_shift_right_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 11:
        	    // gruntEval.g:476:4: ^( OP_AND_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_AND_ASSIGN, &FOLLOW_OP_AND_ASSIGN_in_expr1112); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1116);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1120);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_and_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 12:
        	    // gruntEval.g:477:4: ^( OP_OR_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_OR_ASSIGN, &FOLLOW_OP_OR_ASSIGN_in_expr1130); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1134);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1138);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_or_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 13:
        	    // gruntEval.g:478:4: ^( OP_XOR_ASSIGN e0= expr e1= expr )
        	    {
        	         MATCHT(OP_XOR_ASSIGN, &FOLLOW_OP_XOR_ASSIGN_in_expr1149); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1153);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1157);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_xor_assign(e0, e1);
        	        }

        	    }
        	    break;
        	case 14:
        	    // gruntEval.g:479:4: ^( OP_LOGICAL_OR e0= expr e1= expr )
        	    {
        	         MATCHT(OP_LOGICAL_OR, &FOLLOW_OP_LOGICAL_OR_in_expr1167); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1171);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1175);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_logical_or(e0, e1);
        	        }

        	    }
        	    break;
        	case 15:
        	    // gruntEval.g:480:4: ^( OP_LOGICAL_AND e0= expr e1= expr )
        	    {
        	         MATCHT(OP_LOGICAL_AND, &FOLLOW_OP_LOGICAL_AND_in_expr1185); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1189);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1193);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_logical_and(e0, e1);
        	        }

        	    }
        	    break;
        	case 16:
        	    // gruntEval.g:481:4: ^( OP_BITWISE_OR e0= expr e1= expr )
        	    {
        	         MATCHT(OP_BITWISE_OR, &FOLLOW_OP_BITWISE_OR_in_expr1203); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1207);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1211);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_bitwise_or(e0, e1);
        	        }

        	    }
        	    break;
        	case 17:
        	    // gruntEval.g:482:4: ^( OP_BITWISE_XOR e0= expr e1= expr )
        	    {
        	         MATCHT(OP_BITWISE_XOR, &FOLLOW_OP_BITWISE_XOR_in_expr1221); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1225);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1229);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_bitwise_xor(e0, e1);
        	        }

        	    }
        	    break;
        	case 18:
        	    // gruntEval.g:483:4: ^( OP_BITWISE_AND e0= expr e1= expr )
        	    {
        	         MATCHT(OP_BITWISE_AND, &FOLLOW_OP_BITWISE_AND_in_expr1239); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1243);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1247);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_bitwise_and(e0, e1);
        	        }

        	    }
        	    break;
        	case 19:
        	    // gruntEval.g:484:4: ^( OP_EQUAL e0= expr e1= expr )
        	    {
        	         MATCHT(OP_EQUAL, &FOLLOW_OP_EQUAL_in_expr1257); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1261);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1265);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_equal(e0, e1);
        	        }

        	    }
        	    break;
        	case 20:
        	    // gruntEval.g:485:4: ^( OP_NOT_EQUAL e0= expr e1= expr )
        	    {
        	         MATCHT(OP_NOT_EQUAL, &FOLLOW_OP_NOT_EQUAL_in_expr1276); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1280);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1284);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_not_equal(e0, e1);
        	        }

        	    }
        	    break;
        	case 21:
        	    // gruntEval.g:486:4: ^( OP_LESS e0= expr e1= expr )
        	    {
        	         MATCHT(OP_LESS, &FOLLOW_OP_LESS_in_expr1295); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1299);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1303);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_less(e0, e1);
        	        }

        	    }
        	    break;
        	case 22:
        	    // gruntEval.g:487:4: ^( OP_LESS_EQUAL e0= expr e1= expr )
        	    {
        	         MATCHT(OP_LESS_EQUAL, &FOLLOW_OP_LESS_EQUAL_in_expr1314); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1318);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1322);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_less_equal(e0, e1);
        	        }

        	    }
        	    break;
        	case 23:
        	    // gruntEval.g:488:4: ^( OP_GREATER e0= expr e1= expr )
        	    {
        	         MATCHT(OP_GREATER, &FOLLOW_OP_GREATER_in_expr1332); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1336);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1340);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_greater(e0, e1);
        	        }

        	    }
        	    break;
        	case 24:
        	    // gruntEval.g:489:4: ^( OP_GREATER_EQUAL e0= expr e1= expr )
        	    {
        	         MATCHT(OP_GREATER_EQUAL, &FOLLOW_OP_GREATER_EQUAL_in_expr1351); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1355);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1359);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_greater_equal(e0, e1);
        	        }

        	    }
        	    break;
        	case 25:
        	    // gruntEval.g:490:4: ^( OP_SHIFT_LEFT e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SHIFT_LEFT, &FOLLOW_OP_SHIFT_LEFT_in_expr1369); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1373);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1377);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_shift_left(e0, e1);
        	        }

        	    }
        	    break;
        	case 26:
        	    // gruntEval.g:491:4: ^( OP_SHIFT_RIGHT e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SHIFT_RIGHT, &FOLLOW_OP_SHIFT_RIGHT_in_expr1387); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1391);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1395);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_shift_right(e0, e1);
        	        }

        	    }
        	    break;
        	case 27:
        	    // gruntEval.g:492:4: ^( OP_ADD e0= expr e1= expr )
        	    {
        	         MATCHT(OP_ADD, &FOLLOW_OP_ADD_in_expr1405); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1409);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1413);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_add(e0, e1);
        	        }

        	    }
        	    break;
        	case 28:
        	    // gruntEval.g:493:4: ^( OP_SUB e0= expr e1= expr )
        	    {
        	         MATCHT(OP_SUB, &FOLLOW_OP_SUB_in_expr1424); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1428);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1432);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_sub(e0, e1);
        	        }

        	    }
        	    break;
        	case 29:
        	    // gruntEval.g:494:4: ^( OP_MOD e0= expr e1= expr )
        	    {
        	         MATCHT(OP_MOD, &FOLLOW_OP_MOD_in_expr1443); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1447);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1451);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_mod(e0, e1);
        	        }

        	    }
        	    break;
        	case 30:
        	    // gruntEval.g:495:4: ^( OP_MUL e0= expr e1= expr )
        	    {
        	         MATCHT(OP_MUL, &FOLLOW_OP_MUL_in_expr1462); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1466);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1470);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_mul(e0, e1);
        	        }

        	    }
        	    break;
        	case 31:
        	    // gruntEval.g:496:4: ^( OP_DIV e0= expr e1= expr )
        	    {
        	         MATCHT(OP_DIV, &FOLLOW_OP_DIV_in_expr1481); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1485);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1489);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_div(e0, e1);
        	        }

        	    }
        	    break;
        	case 32:
        	    // gruntEval.g:497:4: ^( OP_BITWISE_NOT e0= expr )
        	    {
        	         MATCHT(OP_BITWISE_NOT, &FOLLOW_OP_BITWISE_NOT_in_expr1500); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1504);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_bitwise_not(e0);
        	        }

        	    }
        	    break;
        	case 33:
        	    // gruntEval.g:498:4: ^( OP_LOGICAL_NOT e0= expr )
        	    {
        	         MATCHT(OP_LOGICAL_NOT, &FOLLOW_OP_LOGICAL_NOT_in_expr1515); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1519);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_logical_not(e0);
        	        }

        	    }
        	    break;
        	case 34:
        	    // gruntEval.g:499:4: ^( OP_NEGATE e0= expr )
        	    {
        	         MATCHT(OP_NEGATE, &FOLLOW_OP_NEGATE_in_expr1530); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1534);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_negate(e0);
        	        }

        	    }
        	    break;
        	case 35:
        	    // gruntEval.g:500:4: ^( OP_PRE_INCR e0= expr )
        	    {
        	         MATCHT(OP_PRE_INCR, &FOLLOW_OP_PRE_INCR_in_expr1546); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1550);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_pre_incr(e0);
        	        }

        	    }
        	    break;
        	case 36:
        	    // gruntEval.g:501:4: ^( OP_PRE_DECR e0= expr )
        	    {
        	         MATCHT(OP_PRE_DECR, &FOLLOW_OP_PRE_DECR_in_expr1562); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1566);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_pre_decr(e0);
        	        }

        	    }
        	    break;
        	case 37:
        	    // gruntEval.g:502:4: ^( OP_POST_INCR e0= expr )
        	    {
        	         MATCHT(OP_POST_INCR, &FOLLOW_OP_POST_INCR_in_expr1578); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1582);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_post_incr(e0);
        	        }

        	    }
        	    break;
        	case 38:
        	    // gruntEval.g:503:4: ^( OP_POST_DECR e0= expr )
        	    {
        	         MATCHT(OP_POST_DECR, &FOLLOW_OP_POST_DECR_in_expr1594); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1598);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_post_decr(e0);
        	        }

        	    }
        	    break;
        	case 39:
        	    // gruntEval.g:504:4: ^( OP_ELEMENT e0= expr IDENTIFIER )
        	    {
        	         MATCHT(OP_ELEMENT, &FOLLOW_OP_ELEMENT_in_expr1610); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1614);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        IDENTIFIER18 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expr1616); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_element(e0, (const wchar_t*)(IDENTIFIER18->getText(IDENTIFIER18))->chars);
        	        }

        	    }
        	    break;
        	case 40:
        	    // gruntEval.g:505:4: ^( OP_INDEX e0= expr e1= expr )
        	    {
        	         MATCHT(OP_INDEX, &FOLLOW_OP_INDEX_in_expr1626); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1630);
        	        e0=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr1634);
        	        e1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.op_index(e0, e1);
        	        }

        	    }
        	    break;
        	case 41:
        	    // gruntEval.g:506:4: call_func_expr
        	    {
        	        FOLLOWPUSH(FOLLOW_call_func_expr_in_expr1644);
        	        call_func_expr19=call_func_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= call_func_expr19;
        	        }

        	    }
        	    break;
        	case 42:
        	    // gruntEval.g:507:4: STRING_LITERAL
        	    {
        	        STRING_LITERAL20 = (pANTLR3_BASE_TREE) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_expr1655); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.addTempCell(); value->asString() = wcs((const wchar_t*)(STRING_LITERAL20->getText(STRING_LITERAL20))->chars, (size_t)(STRING_LITERAL20->getText(STRING_LITERAL20))->len);
        	        }

        	    }
        	    break;
        	case 43:
        	    // gruntEval.g:508:4: DECIMAL_INTEGER_LITERAL
        	    {
        	        DECIMAL_INTEGER_LITERAL21 = (pANTLR3_BASE_TREE) MATCHT(DECIMAL_INTEGER_LITERAL, &FOLLOW_DECIMAL_INTEGER_LITERAL_in_expr1666); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.addTempCell(); value->asString() = (const wchar_t*)(DECIMAL_INTEGER_LITERAL21->getText(DECIMAL_INTEGER_LITERAL21))->chars; value->asInteger();
        	        }

        	    }
        	    break;
        	case 44:
        	    // gruntEval.g:509:4: HEXADECIMAL_INTEGER_LITERAL
        	    {
        	         MATCHT(HEXADECIMAL_INTEGER_LITERAL, &FOLLOW_HEXADECIMAL_INTEGER_LITERAL_in_expr1676); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	    }
        	    break;
        	case 45:
        	    // gruntEval.g:510:4: FLOAT_LITERAL
        	    {
        	        FLOAT_LITERAL22 = (pANTLR3_BASE_TREE) MATCHT(FLOAT_LITERAL, &FOLLOW_FLOAT_LITERAL_in_expr1681); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.addTempCell(); value->asString() = (const wchar_t*)(FLOAT_LITERAL22->getText(FLOAT_LITERAL22))->chars; value->asFloat();
        	        }

        	    }
        	    break;
        	case 46:
        	    // gruntEval.g:511:4: IDENTIFIER
        	    {
        	        IDENTIFIER23 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expr1692); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.getIdentifierCell((const wchar_t*)(IDENTIFIER23->getText(IDENTIFIER23))->chars);
        	        }

        	    }
        	    break;
        	case 47:
        	    // gruntEval.g:512:4: function_definition
        	    {
        	        FOLLOWPUSH(FOLLOW_function_definition_in_expr1703);
        	        function_definition24=function_definition(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= function_definition24;
        	        }

        	    }
        	    break;
        	case 48:
        	    // gruntEval.g:513:4: THIS_FUNC
        	    {
        	         MATCHT(THIS_FUNC, &FOLLOW_THIS_FUNC_in_expr1713); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= runtime.getThisFunc(); if(!value) value= runtime.addTempCell();
        	        }

        	    }
        	    break;
        	case 49:
        	    // gruntEval.g:514:4: dictionary_value
        	    {
        	        FOLLOWPUSH(FOLLOW_dictionary_value_in_expr1724);
        	        dictionary_value25=dictionary_value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            value= dictionary_value25;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end expr */

/** 
 * $ANTLR start conditional_expr
 * gruntEval.g:517:1: conditional_expr returns [gruntMemCell* value = NULL] : ^( OP_CONDITIONAL e0= expr ( asnot ) ( asnot ) ) ;
 */
static gruntMemCell*
conditional_expr(pgruntEval ctx)
{   
    gruntMemCell* value =  NULL;

    gruntMemCell* e0;
    #undef	RETURN_TYPE_e0
    #define	RETURN_TYPE_e0 gruntMemCell*

    /* Initialize rule variables
     */



    		ANTLR3_INT32 t_index, f_index;
    	
    e0 = NULL;

    {
        // gruntEval.g:523:2: ( ^( OP_CONDITIONAL e0= expr ( asnot ) ( asnot ) ) )
        // gruntEval.g:523:4: ^( OP_CONDITIONAL e0= expr ( asnot ) ( asnot ) )
        {
             MATCHT(OP_CONDITIONAL, &FOLLOW_OP_CONDITIONAL_in_conditional_expr1753); 
            if  (HASEXCEPTION())
            {
                goto ruleconditional_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditional_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_expr_in_conditional_expr1757);
            e0=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditional_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:523:29: ( asnot )
            // gruntEval.g:523:30: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    t_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_conditional_expr1762);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleconditional_exprEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }

            // gruntEval.g:523:71: ( asnot )
            // gruntEval.g:523:72: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    f_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_conditional_expr1768);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleconditional_exprEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditional_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			if(e0->toBool())
                			{
                				value= exec_rule(ctx, t_index, &expr);
                			}
                			else
                			{
                				value= exec_rule(ctx, f_index, &expr);
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditional_exprEx; /* Prevent compiler warnings */
    ruleconditional_exprEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end conditional_expr */

/** 
 * $ANTLR start call_func_expr
 * gruntEval.g:536:1: call_func_expr returns [gruntMemCell* value] : ^( OP_CALL_FUNC e0= expr ( asnot ) ) ;
 */
static gruntMemCell*
call_func_expr(pgruntEval ctx)
{   
    gruntMemCell* value = NULL;

    gruntMemCell* e0;
    #undef	RETURN_TYPE_e0
    #define	RETURN_TYPE_e0 gruntMemCell*

    /* Initialize rule variables
     */



    		ANTLR3_INT32 a_index;
    		gruntRuntime& runtime = *RUNTIME;
    	
    e0 = NULL;

    {
        // gruntEval.g:543:2: ( ^( OP_CALL_FUNC e0= expr ( asnot ) ) )
        // gruntEval.g:543:4: ^( OP_CALL_FUNC e0= expr ( asnot ) )
        {
             MATCHT(OP_CALL_FUNC, &FOLLOW_OP_CALL_FUNC_in_call_func_expr1798); 
            if  (HASEXCEPTION())
            {
                goto rulecall_func_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecall_func_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_expr_in_call_func_expr1802);
            e0=expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecall_func_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            // gruntEval.g:543:27: ( asnot )
            // gruntEval.g:543:28: asnot
            {
                if ( BACKTRACKING==0 ) 
                {
                    a_index = getCurNodeIndex(ctx);
                }
                FOLLOWPUSH(FOLLOW_asnot_in_call_func_expr1807);
                asnot(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulecall_func_exprEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecall_func_exprEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			if(e0->getType() == gruntMemCell::TYPE_FUNCTION)
                			{
                				gruntMemCell* al = exec_rule(ctx, a_index, &argument_list);
                				gruntEval_get_func_def_return func_def = exec_rule(ctx, (ANTLR3_INT32)e0->toFunction(), &get_func_def);
                				runtime.enterScope(gruntMemCell::SCOPE_FUNCTION);
                				runtime.op_assign(runtime.addLocalCell(L"$fp"), e0);
                				ANTLR3_TREE_PARSER* parser = PARSER;
                				ANTLR3_COMMON_TREE_NODE_STREAM* tns = parser->getTreeNodeStream(parser);
                				ANTLR3_VECTOR* nodes = tns->nodes;
                				size_t count = 0;
                				for(ANTLR3_INT32 i = func_def.param_start; i < func_def.param_end; ++i)
                				{
                					ANTLR3_BASE_TREE* n = (ANTLR3_BASE_TREE*)nodes->get(nodes, i);
                					ANTLR3_COMMON_TOKEN* token = n->getToken(n);
                					ANTLR3_STRING* s = token->getText(token);
                					gruntMemCell* a = runtime.addLocalCell((const wchar_t*)s->chars);
                					runtime.op_assign(a, al->getElement(FORMATW(L"%d", count)));
                					++count;
                				}
                				al->getPool()->deleteCell(al->getIndex());
                				gruntMemCell* ret = exec_rule(ctx, func_def.block_index, &compound_stat_no_scope);
                				runtime.leaveScope();
                				value= runtime.addTempCell();
                				if(ret)
                				{
                					runtime.op_assign(value, ret);
                					ret->getPool()->deleteCell(ret->getIndex());
                				}
                			}
                			else if(e0->getType() == gruntMemCell::TYPE_FUNCTION_BINDING)
                			{
                				gruntMemCell* al = exec_rule(ctx, a_index, &argument_list);

                				gruntMemCell* ret = e0->getFunctionBindingFunc()(e0->getFunctionBindingOpaque(), &runtime, al);
                				value= runtime.addTempCell();
                				if(ret)
                				{
                					runtime.op_assign(value, ret);
                					ret->getPool()->deleteCell(ret->getIndex());
                				}

                				al->getPool()->deleteCell(al->getIndex());
                			}
                			else
                			{
                				printf("not a function\n");
                				value= runtime.addTempCell();
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecall_func_exprEx; /* Prevent compiler warnings */
    rulecall_func_exprEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end call_func_expr */

/** 
 * $ANTLR start argument_list
 * gruntEval.g:596:1: argument_list returns [gruntMemCell* value] : ^( ARGUMENT_LIST ( expr )* ) ;
 */
static gruntMemCell*
argument_list(pgruntEval ctx)
{   
    gruntMemCell* value = NULL;

    gruntMemCell* expr26;
    #undef	RETURN_TYPE_expr26
    #define	RETURN_TYPE_expr26 gruntMemCell*

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    		ptrdiff_t next_index = 0;
    		value= runtime.addCell(L"");
    		value->asDictionary();
    	
    expr26 = NULL;

    {
        // gruntEval.g:605:2: ( ^( ARGUMENT_LIST ( expr )* ) )
        // gruntEval.g:605:4: ^( ARGUMENT_LIST ( expr )* )
        {
             MATCHT(ARGUMENT_LIST, &FOLLOW_ARGUMENT_LIST_in_argument_list1837); 
            if  (HASEXCEPTION())
            {
                goto ruleargument_listEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargument_listEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

                // gruntEval.g:605:20: ( expr )*

                for (;;)
                {
                    int alt18=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA18_0 = LA(1);
                        if ( (((LA18_0 >= OP_ASSIGN) && (LA18_0 <= OP_CALL_FUNC)) || LA18_0 == EMPTY_EXPR || LA18_0 == FUNC_DEF || ((LA18_0 >= THIS_FUNC) && (LA18_0 <= DICT_VALUE)) || ((LA18_0 >= IDENTIFIER) && (LA18_0 <= STRING_LITERAL)) || ((LA18_0 >= DECIMAL_INTEGER_LITERAL) && (LA18_0 <= FLOAT_LITERAL))) ) 
                        {
                            alt18=1;
                        }

                    }
                    switch (alt18) 
                    {
                	case 1:
                	    // gruntEval.g:605:21: expr
                	    {
                	        FOLLOWPUSH(FOLLOW_expr_in_argument_list1840);
                	        expr26=expr(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleargument_listEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }
                	        if ( BACKTRACKING==0 ) 
                	        {
                	            gruntMemCell* e = runtime.addCell(FORMATW(L"%d", next_index)); ++next_index; runtime.op_assign(e, expr26);value->addElement(e);
                	        }

                	    }
                	    break;

                	default:
                	    goto loop18;	/* break out of the loop */
                	    break;
                    }
                }
                loop18: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargument_listEx;
                }
                if (HASFAILED())
                {
                    return value;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleargument_listEx; /* Prevent compiler warnings */
    ruleargument_listEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end argument_list */

/** 
 * $ANTLR start dictionary_value
 * gruntEval.g:608:1: dictionary_value returns [gruntMemCell* value] : ^( DICT_VALUE ( ^( DICT_ELEM_VALUE (id= IDENTIFIER | s= STRING_LITERAL ) expr ) )* ) ;
 */
static gruntMemCell*
dictionary_value(pgruntEval ctx)
{   
    gruntMemCell* value = NULL;

    pANTLR3_BASE_TREE    id;
    pANTLR3_BASE_TREE    s;
    gruntMemCell* expr27;
    #undef	RETURN_TYPE_expr27
    #define	RETURN_TYPE_expr27 gruntMemCell*

    /* Initialize rule variables
     */



    		gruntRuntime& runtime = *RUNTIME;
    	
    id       = NULL;
    s       = NULL;
    expr27 = NULL;

    {
        // gruntEval.g:614:2: ( ^( DICT_VALUE ( ^( DICT_ELEM_VALUE (id= IDENTIFIER | s= STRING_LITERAL ) expr ) )* ) )
        // gruntEval.g:614:4: ^( DICT_VALUE ( ^( DICT_ELEM_VALUE (id= IDENTIFIER | s= STRING_LITERAL ) expr ) )* )
        {
             MATCHT(DICT_VALUE, &FOLLOW_DICT_VALUE_in_dictionary_value1869); 
            if  (HASEXCEPTION())
            {
                goto ruledictionary_valueEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            if ( BACKTRACKING==0 ) 
            {

                				value= runtime.addTempCell();
                				value->asDictionary();
                			
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruledictionary_valueEx;
                }
                if (HASFAILED())
                {
                    return value;
                }

                // gruntEval.g:619:4: ( ^( DICT_ELEM_VALUE (id= IDENTIFIER | s= STRING_LITERAL ) expr ) )*

                for (;;)
                {
                    int alt20=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA20_0 = LA(1);
                        if ( (LA20_0 == DICT_ELEM_VALUE) ) 
                        {
                            alt20=1;
                        }

                    }
                    switch (alt20) 
                    {
                	case 1:
                	    // gruntEval.g:619:5: ^( DICT_ELEM_VALUE (id= IDENTIFIER | s= STRING_LITERAL ) expr )
                	    {
                	         MATCHT(DICT_ELEM_VALUE, &FOLLOW_DICT_ELEM_VALUE_in_dictionary_value1881); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledictionary_valueEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledictionary_valueEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	        // gruntEval.g:619:23: (id= IDENTIFIER | s= STRING_LITERAL )
                	        {
                	            int alt19=2;

                	            {
                	                int LA19_0 = LA(1);
                	                if ( (LA19_0 == IDENTIFIER) ) 
                	                {
                	                    alt19=1;
                	                }
                	                else if ( (LA19_0 == STRING_LITERAL) ) 
                	                {
                	                    alt19=2;
                	                }
                	                else 
                	                {
                	                    if (BACKTRACKING>0)
                	                    {
                	                        FAILEDFLAG = ANTLR3_TRUE; 
                	                        return value;
                	                    }
                	                
                	                    CONSTRUCTEX();
                	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                	                    EXCEPTION->message      = (void *)"";
                	                    EXCEPTION->decisionNum  = 19;
                	                    EXCEPTION->state        = 0;


                	                    goto ruledictionary_valueEx;
                	                }
                	            }
                	            switch (alt19) 
                	            {
                	        	case 1:
                	        	    // gruntEval.g:619:24: id= IDENTIFIER
                	        	    {
                	        	        id = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_dictionary_value1888); 
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruledictionary_valueEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return value;
                	        	        }

                	        	    }
                	        	    break;
                	        	case 2:
                	        	    // gruntEval.g:619:42: s= STRING_LITERAL
                	        	    {
                	        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_dictionary_value1896); 
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruledictionary_valueEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return value;
                	        	        }

                	        	    }
                	        	    break;

                	            }
                	        }
                	        FOLLOWPUSH(FOLLOW_expr_in_dictionary_value1899);
                	        expr27=expr(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledictionary_valueEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }
                	        if ( BACKTRACKING==0 ) 
                	        {

                	            					gruntMemCell* e;
                	            					if(id)
                	            						e = runtime.addCell(wcs((const wchar_t*)(id->getText(id))->chars, (size_t)(id->getText(id))->len));
                	            					else
                	            						e = runtime.addCell(wcs((const wchar_t*)(s->getText(s))->chars, (size_t)(s->getText(s))->len));
                	            					runtime.op_assign(e, expr27);
                	            					value->addElement(e);
                	            				
                	        }

                	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledictionary_valueEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return value;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop20;	/* break out of the loop */
                	    break;
                    }
                }
                loop20: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruledictionary_valueEx;
                }
                if (HASFAILED())
                {
                    return value;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledictionary_valueEx; /* Prevent compiler warnings */
    ruledictionary_valueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return value;
}
/* $ANTLR end dictionary_value */

// $ANTLR start synpred1_gruntEval
static void synpred1_gruntEval_fragment(pgruntEval ctx ) 
{
    // gruntEval.g:249:5: ( ^( SWITCH_CASE_LABEL asnot ) )
    // gruntEval.g:249:6: ^( SWITCH_CASE_LABEL asnot )
    {
         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_synpred1_gruntEval557); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_asnot_in_synpred1_gruntEval559);
        asnot(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_gruntEvalEx; /* Prevent compiler warnings */
rulesynpred1_gruntEvalEx: ;

}
// $ANTLR end synpred1_gruntEval

// $ANTLR start synpred2_gruntEval
static void synpred2_gruntEval_fragment(pgruntEval ctx ) 
{
    // gruntEval.g:250:6: ( SWITCH_CASE_LABEL )
    // gruntEval.g:250:7: SWITCH_CASE_LABEL
    {
         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_synpred2_gruntEval581); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2_gruntEvalEx; /* Prevent compiler warnings */
rulesynpred2_gruntEvalEx: ;

}
// $ANTLR end synpred2_gruntEval

// $ANTLR start synpred3_gruntEval
static void synpred3_gruntEval_fragment(pgruntEval ctx ) 
{
    // gruntEval.g:273:4: ( ^( SWITCH_CASE_LABEL asnot ) )
    // gruntEval.g:273:5: ^( SWITCH_CASE_LABEL asnot )
    {
         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_synpred3_gruntEval659); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_asnot_in_synpred3_gruntEval661);
        asnot(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred3_gruntEvalEx; /* Prevent compiler warnings */
rulesynpred3_gruntEvalEx: ;

}
// $ANTLR end synpred3_gruntEval

// $ANTLR start synpred4_gruntEval
static void synpred4_gruntEval_fragment(pgruntEval ctx ) 
{
    // gruntEval.g:274:5: ( SWITCH_CASE_LABEL )
    // gruntEval.g:274:6: SWITCH_CASE_LABEL
    {
         MATCHT(SWITCH_CASE_LABEL, &FOLLOW_SWITCH_CASE_LABEL_in_synpred4_gruntEval678); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_gruntEvalEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred4_gruntEvalEx; /* Prevent compiler warnings */
rulesynpred4_gruntEvalEx: ;

}
// $ANTLR end synpred4_gruntEval
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred2_gruntEval(pgruntEval ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_gruntEval_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_gruntEval(pgruntEval ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_gruntEval_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_gruntEval(pgruntEval ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_gruntEval_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_gruntEval(pgruntEval ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_gruntEval_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
